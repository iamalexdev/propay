import telebot
from telebot import types
import sqlite3
import uuid
from datetime import datetime
import html
import re
import time
import os
import requests
import json
from bs4 import BeautifulSoup
from flask import Flask, render_template
import threading

# Configuraci√≥n
TOKEN = "8400947960:AAGGXHezQbmUqk6AOpgT1GqMLaF-rMvVp9Y"
GROUP_CHAT_ID = "-4932107704"  # Reemplaza con el ID de tu grupo
ADMIN_ID = 1853800972  # Reemplaza con tu ID de usuario de Telegram
bot = telebot.TeleBot(TOKEN)

# Crear app Flask para Render
app = Flask(__name__)

@app.route('/')
def home():
    return "ü§ñ CubaWallet ProCoin Bot est√° funcionando"

@app.route('/health')
def health():
    return "‚úÖ OK", 200

# Diccionarios para operaciones pendientes
pending_deposits = {}
pending_withdrawals = {}

# APIs para tasas de cambio
API_ENDPOINTS = {
    "eltoque": "https://eltoque.com/tasas-de-cambio-de-moneda-en-cuba-hoy",
    "binance": "https://api.binance.com/api/v3/ticker/price",
    "coingecko": "https://api.coingecko.com/api/v3/simple/price"
}

# Funci√≥n para obtener tasa EUR/USD desde APIs financieras
def get_eur_usd_rate():
    """
    Obtiene la tasa de cambio EUR/USD desde APIs financieras
    Retorna: float o None si hay error
    """
    try:
        # Try CoinGecko first
        url = "https://api.coingecko.com/api/v3/simple/price?ids=usd-coin&vs_currencies=eur"
        response = requests.get(url, timeout=10)
        data = response.json()
        
        if 'usd-coin' in data and 'eur' in data['usd-coin']:
            eur_rate = data['usd-coin']['eur']
            usd_eur_rate = 1 / eur_rate  # Convert to EUR/USD
            print(f"‚úÖ Tasa EUR/USD obtenida de CoinGecko: {usd_eur_rate:.4f}")
            return usd_eur_rate
            
    except Exception as e:
        print(f"‚ùå Error con CoinGecko: {e}")
    
    try:
        # Fallback: API de tipo de cambio
        url = "https://api.exchangerate-api.com/v4/latest/USD"
        response = requests.get(url, timeout=10)
        data = response.json()
        
        if 'rates' in data and 'EUR' in data['rates']:
            usd_eur_rate = data['rates']['EUR']
            print(f"‚úÖ Tasa EUR/USD obtenida de ExchangeRate: {usd_eur_rate:.4f}")
            return usd_eur_rate
            
    except Exception as e:
        print(f"‚ùå Error con ExchangeRate: {e}")
    
    # Fallback: tasa fija aproximada
    default_rate = 0.92  # 1 USD = 0.92 EUR (aproximado)
    print(f"‚ö†Ô∏è Usando tasa EUR/USD por defecto: {default_rate}")
    return default_rate

# Funci√≥n para obtener tasa CUP/USD calculada desde el EURO
def get_cup_usd_rate():
    """
    Obtiene la tasa de cambio CUP/USD calculada desde el EURO de ElToque
    Retorna: float o None si hay error
    """
    try:
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        }
        response = requests.get(API_ENDPOINTS["eltoque"], headers=headers, timeout=10)
        response.raise_for_status()
        
        soup = BeautifulSoup(response.content, 'html.parser')
        all_text = soup.get_text()
        
        # Estrategia 1: Buscar espec√≠ficamente el EURO
        eur_patterns = [
            r'1\s*EUR\s*[=‚âà]\s*([\d.,]+)\s*CUP',
            r'EUR\s*[=:]\s*([\d.,]+)\s*CUP',
            r'EUR\s*([\d.,]+)\s*CUP',
            r'([\d.,]+)\s*CUP\s*por\s*EUR',
            r'EUR\/CUP[^\d]*([\d.,]+)',
            r'‚Ç¨\s*[=:]\s*([\d.,]+)\s*CUP'
        ]
        
        eur_rate = None
        
        for pattern in eur_patterns:
            match = re.search(pattern, all_text, re.IGNORECASE)
            if match:
                rate_str = match.group(1).replace(',', '')
                try:
                    rate = float(rate_str)
                    if 500 <= rate <= 600:  # Rango razonable para EUR
                        eur_rate = rate
                        print(f"‚úÖ Tasa EUR obtenida de ElToque: {eur_rate} CUP/EUR")
                        break
                except ValueError:
                    continue
        
        if eur_rate is None:
            # Estrategia 2: Buscar cualquier n√∫mero en el rango del EURO
            eur_matches = re.findall(r'\b(5[0-9]{2})\b', all_text)
            for match in eur_matches:
                try:
                    rate = float(match)
                    if 530 <= rate <= 560:  # Rango t√≠pico del EUR
                        eur_rate = rate
                        print(f"‚úÖ Tasa EUR aproximada: {eur_rate} CUP/EUR")
                        break
                except ValueError:
                    continue
        
        if eur_rate is None:
            # Fallback: si no encontramos EUR, usar valor por defecto
            eur_rate = 540.0
            print(f"‚ö†Ô∏è No se pudo obtener tasa EUR, usando valor por defecto: {eur_rate}")
        
        # Obtener tasa EUR/USD
        eur_usd_rate = get_eur_usd_rate()
        
        # Calcular CUP/USD: (CUP/EUR) √ó (EUR/USD)
        cup_usd_rate = eur_rate * eur_usd_rate
        
        print(f"üí∞ C√°lculo: {eur_rate} CUP/EUR √ó {eur_usd_rate:.4f} EUR/USD = {cup_usd_rate:.2f} CUP/USD")
        
        # Ajustar a m√∫ltiplo de 5 para hacerlo m√°s realista
        cup_usd_rate = round(cup_usd_rate / 5) * 5
        
        print(f"‚úÖ Tasa CUP/USD calculada: {cup_usd_rate} CUP/USD")
        return cup_usd_rate
        
    except requests.RequestException as e:
        print(f"‚ùå Error de conexi√≥n: {e}")
        return 485.0
    except Exception as e:
        print(f"‚ùå Error inesperado: {e}")
        return 485.0

# Funci√≥n para enviar notificaciones al grupo
def send_group_notification(message, photo_id=None):
    try:
        if photo_id:
            bot.send_photo(
                chat_id=GROUP_CHAT_ID,
                photo=photo_id,
                caption=message,
                parse_mode='Markdown'
            )
        else:
            bot.send_message(
                chat_id=GROUP_CHAT_ID,
                text=message,
                parse_mode='Markdown'
            )
        print(f"‚úÖ Notificaci√≥n enviada al grupo {GROUP_CHAT_ID}")
        return True
    except Exception as e:
        print(f"‚ùå Error enviando notificaci√≥n: {e}")
        return False

# Inicializar Base de Datos
def init_db():
    conn = sqlite3.connect('cubawallet.db')
    cursor = conn.cursor()
    
    # Tabla de usuarios
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS users (
            user_id INTEGER PRIMARY KEY,
            username TEXT,
            first_name TEXT,
            balance REAL DEFAULT 0.0,
            wallet_address TEXT UNIQUE,
            registered_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
    ''')
    
    # Tabla de transacciones
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS transactions (
            transaction_id TEXT PRIMARY KEY,
            from_user INTEGER,
            to_user INTEGER,
            amount REAL,
            currency TEXT DEFAULT 'PRC',
            transaction_type TEXT,
            status TEXT,
            timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (from_user) REFERENCES users (user_id),
            FOREIGN KEY (to_user) REFERENCES users (user_id)
        )
    ''')
    
    # Tabla de dep√≥sitos
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS deposits (
            deposit_id TEXT PRIMARY KEY,
            user_id INTEGER,
            amount_cup REAL,
            amount_prc REAL,
            exchange_rate REAL,
            method TEXT,
            status TEXT,
            screenshot_id TEXT,
            admin_approved INTEGER,
            timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (user_id) REFERENCES users (user_id)
        )
    ''')
    
    # Tabla de retiros
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS withdrawals (
            withdrawal_id TEXT PRIMARY KEY,
            user_id INTEGER,
            amount_prc REAL,
            amount_cup REAL,
            exchange_rate REAL,
            fee REAL,
            net_amount REAL,
            card_number TEXT,
            status TEXT,
            screenshot_id TEXT,
            admin_approved INTEGER,
            timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (user_id) REFERENCES users (user_id)
        )
    ''')
    
    conn.commit()
    conn.close()

# Funci√≥n para limpiar la base de datos (solo admin)
def clear_database():
    try:
        conn = sqlite3.connect('cubawallet.db')
        cursor = conn.cursor()
        
        cursor.execute('DROP TABLE IF EXISTS withdrawals')
        cursor.execute('DROP TABLE IF EXISTS deposits')
        cursor.execute('DROP TABLE IF EXISTS transactions')
        cursor.execute('DROP TABLE IF EXISTS users')
        
        conn.commit()
        conn.close()
        
        init_db()
        return True
    except Exception as e:
        print(f"Error limpiando base de datos: {e}")
        return False

# Funci√≥n para escapar texto para Markdown
def escape_markdown(text):
    if text is None:
        return ""
    escape_chars = ['_', '*', '[', ']', '(', ')', '~', '`', '>', '#', '+', '-', '=', '|', '{', '}', '.', '!']
    for char in escape_chars:
        text = str(text).replace(char, f'\\{char}')
    return text

# Funci√≥n para verificar si es administrador
def is_admin(user_id):
    return user_id == ADMIN_ID

# Generar direcci√≥n √∫nica de wallet
def generate_wallet_address():
    return f"PRC{uuid.uuid4().hex[:12].upper()}"

# Registrar usuario en la base de datos
def register_user(user_id, username, first_name):
    conn = sqlite3.connect('cubawallet.db')
    cursor = conn.cursor()
    
    cursor.execute('SELECT * FROM users WHERE user_id = ?', (user_id,))
    user = cursor.fetchone()
    
    if not user:
        wallet_address = generate_wallet_address()
        cursor.execute('''
            INSERT INTO users (user_id, username, first_name, wallet_address, balance)
            VALUES (?, ?, ?, ?, ?)
        ''', (user_id, username, first_name, wallet_address, 0.0))
        conn.commit()
        
        notification_text = f"""
üÜï *NUEVO USUARIO REGISTRADO* üÜï

*Informaci√≥n del usuario:*
‚Ä¢ *Nombre:* {escape_markdown(first_name)}
‚Ä¢ *Username:* @{escape_markdown(username) if username else 'N/A'}
‚Ä¢ *User ID:* `{user_id}`
‚Ä¢ *Wallet:* `{wallet_address}`

*¬°Bienvenido a la familia ProCoin\!*"""
        
        send_group_notification(notification_text)
    
    conn.close()

# Obtener informaci√≥n del usuario
def get_user_info(user_id):
    conn = sqlite3.connect('cubawallet.db')
    cursor = conn.cursor()
    cursor.execute('SELECT * FROM users WHERE user_id = ?', (user_id,))
    user = cursor.fetchone()
    conn.close()
    return user

# Obtener usuario por wallet address
def get_user_by_wallet(wallet_address):
    conn = sqlite3.connect('cubawallet.db')
    cursor = conn.cursor()
    cursor.execute('SELECT * FROM users WHERE wallet_address = ?', (wallet_address,))
    user = cursor.fetchone()
    conn.close()
    return user

# Actualizar balance ProCoin
def update_balance(user_id, amount):
    conn = sqlite3.connect('cubawallet.db')
    cursor = conn.cursor()
    cursor.execute('UPDATE users SET balance = balance + ? WHERE user_id = ?', (amount, user_id))
    conn.commit()
    conn.close()

# Registrar transacci√≥n ProCoin
def log_transaction(transaction_id, from_user, to_user, amount, transaction_type, status):
    conn = sqlite3.connect('cubawallet.db')
    cursor = conn.cursor()
    cursor.execute('''
        INSERT INTO transactions (transaction_id, from_user, to_user, amount, transaction_type, status)
        VALUES (?, ?, ?, ?, ?, ?)
    ''', (transaction_id, from_user, to_user, amount, transaction_type, status))
    conn.commit()
    conn.close()

# Registrar dep√≥sito CUP
def log_deposit(deposit_id, user_id, amount_cup, amount_prc, exchange_rate, method, status, screenshot_id=None):
    conn = sqlite3.connect('cubawallet.db')
    cursor = conn.cursor()
    cursor.execute('''
        INSERT INTO deposits (deposit_id, user_id, amount_cup, amount_prc, exchange_rate, method, status, screenshot_id)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    ''', (deposit_id, user_id, amount_cup, amount_prc, exchange_rate, method, status, screenshot_id))
    conn.commit()
    conn.close()

# Registrar retiro
def log_withdrawal(withdrawal_id, user_id, amount_prc, amount_cup, exchange_rate, fee, net_amount, card_number, status, screenshot_id=None):
    conn = sqlite3.connect('cubawallet.db')
    cursor = conn.cursor()
    cursor.execute('''
        INSERT INTO withdrawals (withdrawal_id, user_id, amount_prc, amount_cup, exchange_rate, fee, net_amount, card_number, status, screenshot_id)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    ''', (withdrawal_id, user_id, amount_prc, amount_cup, exchange_rate, fee, net_amount, card_number, status, screenshot_id))
    conn.commit()
    conn.close()

# Men√∫ principal con botones inline
def main_menu(chat_id):
    markup = types.InlineKeyboardMarkup(row_width=2)
    
    btn_send = types.InlineKeyboardButton("üì§ Enviar ProCoin", callback_data="send_money")
    btn_receive = types.InlineKeyboardButton("üì• Recibir ProCoin", callback_data="receive_money")
    btn_deposit = types.InlineKeyboardButton("üíµ Depositar CUP", callback_data="deposit_cup")
    btn_withdraw = types.InlineKeyboardButton("üí∏ Retirar CUP", callback_data="withdraw_cup")
    btn_balance = types.InlineKeyboardButton("üí∞ Ver Saldo", callback_data="check_balance")
    btn_rates = types.InlineKeyboardButton("üìà Ver Tasas", callback_data="check_rates")
    
    markup.add(btn_send, btn_receive, btn_deposit, btn_withdraw, btn_balance, btn_rates)
    
    return markup

# COMANDOS DE ADMINISTRADOR

@bot.message_handler(commands=['limpiar'])
def clear_database_command(message):
    user_id = message.from_user.id
    
    if not is_admin(user_id):
        bot.reply_to(message, "‚ùå *Comando solo para administradores*", parse_mode='Markdown')
        return
    
    markup = types.InlineKeyboardMarkup()
    btn_confirm = types.InlineKeyboardButton("‚úÖ S√≠, limpiar todo", callback_data="confirm_clear")
    btn_cancel = types.InlineKeyboardButton("‚ùå Cancelar", callback_data="cancel_clear")
    markup.add(btn_confirm, btn_cancel)
    
    bot.reply_to(message,
                "‚ö†Ô∏è *¬øEST√ÅS SEGURO DE QUE QUIERES LIMPIAR LA BASE DE DATOS?*\n\n"
                "üö® *ESTA ACCI√ìN ELIMINAR√Å:*\n"
                "‚Ä¢ Todos los usuarios registrados\n"
                "‚Ä¢ Todas las transacciones\n" 
                "‚Ä¢ Todos los dep√≥sitos y retiros\n\n"
                "üî¥ *¬°ESTA ACCI√ìN NO SE PUEDE DESHACER!*",
                parse_mode='Markdown',
                reply_markup=markup)

@bot.message_handler(commands=['recargar'])
def recharge_balance(message):
    user_id = message.from_user.id
    
    if not is_admin(user_id):
        bot.reply_to(message, "‚ùå *Comando solo para administradores*", parse_mode='Markdown')
        return
    
    parts = message.text.split()
    if len(parts) != 3:
        bot.reply_to(message, 
                    "‚ùå *Formato incorrecto*\n\n"
                    "Uso: `/recargar PRCABC123 100.50`\n\n"
                    "‚Ä¢ PRCABC123 = Wallet del usuario\n"
                    "‚Ä¢ 100.50 = Cantidad de ProCoin a recargar", 
                    parse_mode='Markdown')
        return
    
    wallet_address = parts[1]
    try:
        amount = float(parts[2])
    except ValueError:
        bot.reply_to(message, "‚ùå *Cantidad inv√°lida*", parse_mode='Markdown')
        return
    
    user_info = get_user_by_wallet(wallet_address)
    if not user_info:
        bot.reply_to(message, f"‚ùå *Wallet no encontrada:* `{wallet_address}`", parse_mode='Markdown')
        return
    
    old_balance = user_info[3]
    update_balance(user_info[0], amount)
    new_balance = old_balance + amount
    
    transaction_id = f"ADM{uuid.uuid4().hex[:10].upper()}"
    log_transaction(transaction_id, None, user_info[0], amount, "admin_recharge", "completed")
    
    try:
        user_notification = f"""
üíé *RECARGA DE PROCOIN APROBADA*

‚úÖ Se ha recargado tu cuenta con ProCoin.

üìä *Detalles:*
‚Ä¢ ProCoin recargados: {amount:.2f} PRC
‚Ä¢ Wallet: `{wallet_address}`
‚Ä¢ Transacci√≥n: {transaction_id}
‚Ä¢ Saldo anterior: {old_balance:.2f} PRC
‚Ä¢ Nuevo saldo: *{new_balance:.2f} PRC*

¬°Gracias por usar ProCoin! üéâ"""
        
        bot.send_message(user_info[0], user_notification, parse_mode='Markdown')
    except Exception as e:
        print(f"No se pudo notificar al usuario: {e}")
    
    group_notification = f"""
üíé *RECARGA MANUAL DE PROCOIN* üíé

*Administrador:* {escape_markdown(message.from_user.first_name)}
*Usuario:* {escape_markdown(user_info[2])}
*Wallet:* `{wallet_address}`
*ProCoin:* {amount:.2f} PRC
*Transacci√≥n:* `{transaction_id}`
*Nuevo saldo:* {new_balance:.2f} PRC

‚úÖ *Recarga completada exitosamente*"""
    
    send_group_notification(group_notification)
    
    bot.reply_to(message, 
                f"‚úÖ *Recarga exitosa*\n\n"
                f"Usuario: {escape_markdown(user_info[2])}\n"
                f"ProCoin: {amount:.2f} PRC\n"
                f"Nuevo saldo: {new_balance:.2f} PRC",
                parse_mode='Markdown')

@bot.message_handler(commands=['tasas'])
def show_rates_command(message):
    """Comando para ver tasas actuales"""
    show_current_rates(message)

@bot.message_handler(commands=['estadisticas'])
def show_stats(message):
    user_id = message.from_user.id
    
    if not is_admin(user_id):
        bot.reply_to(message, "‚ùå *Comando solo para administradores*", parse_mode='Markdown')
        return
        
    conn = sqlite3.connect('cubawallet.db')
    cursor = conn.cursor()
    
    # Total de usuarios
    cursor.execute('SELECT COUNT(*) FROM users')
    total_users = cursor.fetchone()[0]
    
    # Total de transacciones
    cursor.execute('SELECT COUNT(*) FROM transactions')
    total_transactions = cursor.fetchone()[0]
    
    # Volumen total en ProCoin
    cursor.execute('SELECT SUM(amount) FROM transactions WHERE status = "completed"')
    total_volume_prc = cursor.fetchone()[0] or 0
    
    # Dep√≥sitos pendientes
    cursor.execute('SELECT COUNT(*) FROM deposits WHERE status = "pending"')
    pending_deposits_count = cursor.fetchone()[0]
    
    # Retiros pendientes
    cursor.execute('SELECT COUNT(*) FROM withdrawals WHERE status = "pending"')
    pending_withdrawals_count = cursor.fetchone()[0]
    
    conn.close()
    
    # Obtener tasas actuales
    cup_rate = get_cup_usd_rate()
    
    stats_text = f"""
üìà *ESTAD√çSTICAS DE PROCOIN*

üë• *Usuarios registrados:* {total_users}
üîÑ *Transacciones ProCoin:* {total_transactions}
üíé *Volumen ProCoin:* {total_volume_prc:.2f} PRC
üí∞ *Volumen equivalente CUP:* {total_volume_prc * cup_rate:,.0f} CUP

‚è≥ *Dep√≥sitos pendientes:* {pending_deposits_count}
‚è≥ *Retiros pendientes:* {pending_withdrawals_count}
üìÖ *Actualizado:* {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"""
    
    bot.send_message(
        message.chat.id,
        stats_text,
        parse_mode='Markdown'
    )

# COMANDO START
@bot.message_handler(commands=['start'])
def send_welcome(message):
    user_id = message.from_user.id
    username = message.from_user.username
    first_name = message.from_user.first_name
    
    register_user(user_id, username, first_name)
    user_info = get_user_info(user_id)
    
    # Obtener tasas actuales
    cup_rate = get_cup_usd_rate()
    
    welcome_text = f"""
üëã ¬°Bienvenido a ProCoin, {escape_markdown(first_name)}!

üíé *Tu Billetera Digital con ProCoin*

üìä *Informaci√≥n de tu cuenta:*
‚Ä¢ Usuario: {escape_markdown(first_name)}
‚Ä¢ Wallet: `{user_info[4]}`
‚ö° *Selecciona una opci√≥n:*"""
    
    bot.send_message(
        chat_id=message.chat.id,
        text=welcome_text,
        parse_mode='Markdown',
        reply_markup=main_menu(message.chat.id)
    )

# MANEJADOR DE CALLBACKS
@bot.callback_query_handler(func=lambda call: True)
def handle_callback(call):
    user_id = call.from_user.id
    user_info = get_user_info(user_id)
    
    if call.data == "send_money":
        msg = bot.send_message(
            call.message.chat.id,
            "üíé *ENVIAR PROCOIN*\n\nüìß Ingresa la direcci√≥n de wallet del destinatario:",
            parse_mode='Markdown'
        )
        bot.register_next_step_handler(msg, process_recipient)
    
    elif call.data == "receive_money":
        receive_text = f"""
üì• *RECIBIR PROCOIN*

üÜî *Tu Direcci√≥n de Wallet:*
`{user_info[4]}`

üìã *Instrucciones:*
1\. Comparte esta direcci√≥n con quien te enviar√° ProCoin
2\. El remitente debe usar la opci√≥n *\"Enviar ProCoin\"*
3\. Ingresa tu direcci√≥n √∫nica mostrada arriba
4\. ¬°Recibir√°s los ProCoin instant√°neamente\!

üí° *Consejo:* Copia tu direcci√≥n haciendo clic en ella\."""
        
        bot.edit_message_text(
            chat_id=call.message.chat.id,
            message_id=call.message.message_id,
            text=receive_text,
            parse_mode='Markdown',
            reply_markup=main_menu(call.message.chat.id)
        )
    
    elif call.data == "deposit_cup":
        # Obtener tasa actual
        cup_rate = get_cup_usd_rate()
        
        deposit_text = f"""
üíµ *DEPOSITAR CUP*

Actualmente 1 PRC = *{cup_rate:,.0f} CUP*

üí° *¬øC√≥mo funciona?*
1. Depositas CUP via Transferm√≥vil/EnZona
2. Se convierte autom√°ticamente a ProCoin
3. Recibes ProCoin en tu wallet al tipo de cambio actual

üìä *Ejemplo:*
‚Ä¢ Si depositas {cup_rate:,.0f} CUP
‚Ä¢ Recibir√°s 1.00 PRC

üíé *Selecciona el m√©todo de pago:*"""
        
        deposit_methods = types.InlineKeyboardMarkup(row_width=2)
        btn_transfermovil = types.InlineKeyboardButton("üì± Transferm√≥vil", callback_data="deposit_transfermovil")
        btn_enzona = types.InlineKeyboardButton("üîµ EnZona", callback_data="deposit_enzona")
        btn_back = types.InlineKeyboardButton("üîô Volver", callback_data="back_to_main")
        deposit_methods.add(btn_transfermovil, btn_enzona, btn_back)
        
        bot.edit_message_text(
            chat_id=call.message.chat.id,
            message_id=call.message.message_id,
            text=deposit_text,
            parse_mode='Markdown',
            reply_markup=deposit_methods
        )
    
    elif call.data == "withdraw_cup":
        start_cup_withdrawal(call)
    
    elif call.data == "check_balance":
        show_complete_balance(call)
    
    elif call.data == "check_rates":
        show_current_rates(call)
    
    elif call.data == "deposit_transfermovil":
        start_cup_deposit(call, "transfermovil")
    
    elif call.data == "deposit_enzona":
        start_cup_deposit(call, "enzona")
    
    elif call.data == "back_to_main":
        user_info = get_user_info(user_id)
        cup_rate = get_cup_usd_rate()
        
        welcome_back_text = f"""
üëã ¬°Hola de nuevo, {escape_markdown(user_info[2])}!

üíé *Tu Billetera ProCoin*

üìä *Informaci√≥n actual:*
‚Ä¢ Saldo: {user_info[3]:.2f} PRC
‚Ä¢ Equivalente: {user_info[3] * cup_rate:,.0f} CUP
‚Ä¢ Wallet: `{user_info[4]}`

üí± *Tasa actual:* 1 PRC = {cup_rate:,.0f} CUP

‚ö° *Selecciona una opci√≥n:*"""
        
        bot.edit_message_text(
            chat_id=call.message.chat.id,
            message_id=call.message.message_id,
            text=welcome_back_text,
            parse_mode='Markdown',
            reply_markup=main_menu(call.message.chat.id)
        )
    
    elif call.data == "confirm_clear":
        if is_admin(user_id):
            success = clear_database()
            if success:
                notification_text = f"""
üóëÔ∏è *BASE DE DATOS LIMPIADA* üóëÔ∏è

*Administrador:* {escape_markdown(call.from_user.first_name)}
*Fecha:* {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

‚úÖ *Todas las tablas han sido reiniciadas*
‚úÖ *Sistema listo para nuevos usuarios*"""
                
                send_group_notification(notification_text)
                
                bot.edit_message_text(
                    chat_id=call.message.chat.id,
                    message_id=call.message.message_id,
                    text="‚úÖ *Base de datos limpiada exitosamente*\n\nTodos los datos han sido eliminados y las tablas reiniciadas.",
                    parse_mode='Markdown'
                )
            else:
                bot.edit_message_text(
                    chat_id=call.message.chat.id,
                    message_id=call.message.message_id,
                    text="‚ùå *Error limpiando la base de datos*",
                    parse_mode='Markdown'
                )
    
    elif call.data == "cancel_clear":
        bot.edit_message_text(
            chat_id=call.message.chat.id,
            message_id=call.message.message_id,
            text="‚ùå *Limpieza cancelada*",
            parse_mode='Markdown'
        )

# FUNCIONES PARA DEP√ìSITOS CUP
def start_cup_deposit(call, method):
    cup_rate = get_cup_usd_rate()
    
    msg = bot.send_message(
        call.message.chat.id,
        f"üíµ *DEP√ìSITO POR {method.upper()}*\n\n"
        f"üí± *Tasa actual:* 1 PRC = {cup_rate:,.0f} CUP\n\n"
        f"üíµ Ingresa el monto en CUP que vas a depositar:",
        parse_mode='Markdown'
    )
    bot.register_next_step_handler(msg, process_cup_deposit_amount, method)

def process_cup_deposit_amount(message, method):
    try:
        amount_cup = float(message.text)
        user_id = message.from_user.id
        
        if amount_cup <= 0:
            bot.send_message(
                message.chat.id,
                "‚ùå *Monto inv√°lido*\nEl monto debe ser mayor a 0.",
                parse_mode='Markdown',
                reply_markup=main_menu(message.chat.id)
            )
            return
        
        # Obtener tasa actual
        cup_rate = get_cup_usd_rate()
        amount_prc = amount_cup / cup_rate
        
        # Guardar dep√≥sito pendiente
        deposit_id = f"DEP{uuid.uuid4().hex[:10].upper()}"
        pending_deposits[user_id] = {
            'deposit_id': deposit_id,
            'amount_cup': amount_cup,
            'amount_prc': amount_prc,
            'exchange_rate': cup_rate,
            'method': method
        }
        
        if method == "transfermovil":
            payment_text = f"""
üì± *INSTRUCCIONES PARA PAGO POR TRANSFERM√ìVIL*

üí≥ *Informaci√≥n para transferir:*
‚Ä¢ *Tel√©fono:* `5351234567`
‚Ä¢ *Nombre:* ProCoin Exchange
‚Ä¢ *Monto a transferir:* *{amount_cup:,.0f} CUP*

üìä *Conversi√≥n:*
‚Ä¢ CUP depositados: {amount_cup:,.0f} CUP
‚Ä¢ Tasa: 1 PRC = {cup_rate:,.0f} CUP
‚Ä¢ ProCoin a recibir: *{amount_prc:.2f} PRC*

üìã *Pasos a seguir:*
1\. Abre tu app de Transferm√≥vil
2\. Selecciona *\"Transferir\"*
3\. Ingresa el tel√©fono: *5351234567*
4\. Ingresa el monto: *{amount_cup:,.0f} CUP*
5\. Confirma la transferencia
6\. Toma una *captura de pantalla* del comprobante
7\. Env√≠ala aqu√≠

‚ö†Ô∏è *Importante:* 
‚Ä¢ El monto debe ser *exactamente* {amount_cup:,.0f} CUP
‚Ä¢ Solo se aceptan transferencias desde CUENTAS PROPIAS
‚Ä¢ La verificaci√≥n puede tomar 5-15 minutos"""
        
        else:  # enzona
            payment_text = f"""
üîµ *INSTRUCCIONES PARA PAGO POR ENZONA*

üí≥ *Informaci√≥n para pagar:*
‚Ä¢ *Nombre:* ProCoin Exchange
‚Ä¢ *Monto a pagar:* *{amount_cup:,.0f} CUP*

üìä *Conversi√≥n:*
‚Ä¢ CUP depositados: {amount_cup:,.0f} CUP
‚Ä¢ Tasa: 1 PRC = {cup_rate:,.0f} CUP
‚Ä¢ ProCoin a recibir: *{amount_prc:.2f} PRC*

üìã *Pasos a seguir:*
1\. Abre tu app de EnZona
2\. Escanea el c√≥digo QR o busca *\"ProCoin Exchange\"*
3\. Ingresa el monto: *{amount_cup:,.0f} CUP*
4\. Realiza el pago
5\. Toma una *captura de pantalla* del comprobante
6\. Env√≠ala aqu√≠

‚ö†Ô∏è *Importante:* 
‚Ä¢ El monto debe ser *exactamente* {amount_cup:,.0f} CUP
‚Ä¢ Solo se aceptan pagos desde CUENTAS PROPIAS
‚Ä¢ La verificaci√≥n puede tomar 5-15 minutos"""
        
        # Registrar dep√≥sito pendiente
        log_deposit(deposit_id, user_id, amount_cup, amount_prc, cup_rate, method, "pending")
        
        bot.send_message(
            message.chat.id,
            payment_text,
            parse_mode='Markdown'
        )
        
        msg = bot.send_message(
            message.chat.id,
            "üì∏ *Ahora env√≠a la captura de pantalla del comprobante de pago:*",
            parse_mode='Markdown'
        )
        
    except ValueError:
        bot.send_message(
            message.chat.id,
            "‚ùå *Formato inv√°lido*\nIngresa un n√∫mero v√°lido.",
            parse_mode='Markdown',
            reply_markup=main_menu(message.chat.id)
        )

# FUNCIONES PARA RETIROS CUP
def start_cup_withdrawal(call):
    user_id = call.from_user.id
    user_info = get_user_info(user_id)
    cup_rate = get_cup_usd_rate()
    
    msg = bot.send_message(
        call.message.chat.id,
        f"üí∏ *RETIRAR CUP*\n\n"
        f"üíé *Saldo disponible:* {user_info[3]:.2f} PRC\n"
        f"üíµ *Equivalente:* {user_info[3] * cup_rate:,.0f} CUP\n\n"
        f"üí± *Tasa actual:* 1 PRC = {cup_rate:,.0f} CUP\n\n"
        f"üíé Ingresa la cantidad de ProCoin que deseas retirar (se convertir√°n a CUP):",
        parse_mode='Markdown'
    )
    bot.register_next_step_handler(msg, process_cup_withdraw_amount)

def process_cup_withdraw_amount(message):
    try:
        amount_prc = float(message.text)
        user_id = message.from_user.id
        user_info = get_user_info(user_id)
        
        if amount_prc <= 0:
            bot.send_message(
                message.chat.id,
                "‚ùå *Monto inv√°lido*\nEl monto debe ser mayor a 0.",
                parse_mode='Markdown',
                reply_markup=main_menu(message.chat.id)
            )
            return
        
        if amount_prc > user_info[3]:
            bot.send_message(
                message.chat.id,
                f"‚ùå *Saldo insuficiente*\n\n"
                f"Tu saldo: {user_info[3]:.2f} PRC\n"
                f"Monto a retirar: {amount_prc:.2f} PRC",
                parse_mode='Markdown',
                reply_markup=main_menu(message.chat.id)
            )
            return
        
        # Calcular fee del 2% (puedes ajustar)
        fee = amount_prc * 0.02
        net_amount_prc = amount_prc - fee
        
        # Obtener tasa actual
        cup_rate = get_cup_usd_rate()
        amount_cup = net_amount_prc * cup_rate
        
        # Guardar retiro pendiente
        withdrawal_id = f"WDL{uuid.uuid4().hex[:10].upper()}"
        pending_withdrawals[user_id] = {
            'withdrawal_id': withdrawal_id,
            'amount_prc': amount_prc,
            'amount_cup': amount_cup,
            'exchange_rate': cup_rate,
            'fee': fee,
            'net_amount': net_amount_prc
        }
        
        bot.send_message(
            message.chat.id,
            f"üí≥ *INGRESA TU N√öMERO DE TARJETA*\n\n"
            f"üìã *Resumen del retiro:*\n"
            f"‚Ä¢ ProCoin a retirar: {amount_prc:.2f} PRC\n"
            f"‚Ä¢ Fee (2%): {fee:.2f} PRC\n"
            f"‚Ä¢ Neto a convertir: {net_amount_prc:.2f} PRC\n"
            f"‚Ä¢ Tasa: 1 PRC = {cup_rate:,.0f} CUP\n"
            f"‚Ä¢ Recibir√°s: {amount_cup:,.0f} CUP\n\n"
            f"üî¢ *Ingresa el n√∫mero de tu tarjeta:*",
            parse_mode='Markdown'
        )
        
        bot.register_next_step_handler(message, process_cup_withdraw_card)
        
    except ValueError:
        bot.send_message(
            message.chat.id,
            "‚ùå *Formato inv√°lido*\nIngresa un n√∫mero v√°lido.",
            parse_mode='Markdown',
            reply_markup=main_menu(message.chat.id)
        )

def process_cup_withdraw_card(message):
    user_id = message.from_user.id
    user_info = get_user_info(user_id)
    card_number = message.text.strip()
    
    if user_id not in pending_withdrawals:
        bot.send_message(
            message.chat.id,
            "‚ùå *No hay retiro pendiente*",
            parse_mode='Markdown',
            reply_markup=main_menu(message.chat.id)
        )
        return
    
    withdrawal_data = pending_withdrawals[user_id]
    withdrawal_id = withdrawal_data['withdrawal_id']
    
    if len(card_number) < 10:
        bot.send_message(
            message.chat.id,
            "‚ùå *N√∫mero de tarjeta inv√°lido*\n\nIngresa un n√∫mero de tarjeta v√°lido.",
            parse_mode='Markdown',
            reply_markup=main_menu(message.chat.id)
        )
        return
    
    # Registrar retiro en la base de datos
    log_withdrawal(withdrawal_id, user_id, 
                  withdrawal_data['amount_prc'], withdrawal_data['amount_cup'],
                  withdrawal_data['exchange_rate'], withdrawal_data['fee'],
                  withdrawal_data['net_amount'], card_number, "pending")
    
    # Actualizar balance (congelar fondos)
    update_balance(user_id, -withdrawal_data['amount_prc'])
    
    # Notificar al grupo
    group_notification = f"""
üì§ *NUEVA SOLICITUD DE RETIRO CUP* üì§

*Usuario:* {escape_markdown(user_info[2])}
*Wallet:* `{user_info[4]}`
*ProCoin a retirar:* {withdrawal_data['amount_prc']:.2f} PRC
*CUP a recibir:* {withdrawal_data['amount_cup']:,.0f} CUP
*Tasa:* 1 PRC = {withdrawal_data['exchange_rate']:,.0f} CUP
*Fee (2%):* {withdrawal_data['fee']:.2f} PRC
*Tarjeta:* `{card_number}`
*Retiro ID:* `{withdrawal_id}`

‚è≥ *Esperando procesamiento...*

üíæ *Para aprobar usa:*
`/recargar {user_info[4]} {withdrawal_data['amount_prc']}`"""
    
    send_group_notification(group_notification)
    
    # Confirmar al usuario
    bot.send_message(
        message.chat.id,
        f"‚úÖ *Solicitud de retiro enviada*\n\n"
        f"üìã *Detalles de tu retiro:*\n"
        f"‚Ä¢ ProCoin: {withdrawal_data['amount_prc']:.2f} PRC\n"
        f"‚Ä¢ Fee (2%): {withdrawal_data['fee']:.2f} PRC\n"
        f"‚Ä¢ Neto convertido: {withdrawal_data['net_amount']:.2f} PRC\n"
        f"‚Ä¢ CUP a recibir: {withdrawal_data['amount_cup']:,.0f} CUP\n"
        f"‚Ä¢ Tarjeta: {card_number}\n"
        f"‚Ä¢ Retiro ID: {withdrawal_id}\n\n"
        f"‚è∞ *Estado:* Pendiente de aprobaci√≥n\n"
        f"üìû *Tiempo estimado:* 5-15 minutos\n\n"
        f"Te notificaremos cuando sea procesado.",
        parse_mode='Markdown',
        reply_markup=main_menu(message.chat.id)
    )
    
    # Limpiar retiro pendiente
    del pending_withdrawals[user_id]

# FUNCIONES DE INFORMACI√ìN
def show_complete_balance(call):
    user_id = call.from_user.id
    user_info = get_user_info(user_id)
    
    # Obtener tasas actuales
    cup_rate = get_cup_usd_rate()
    
    balance_text = f"""
üí∞ *BALANCE COMPLETO*

üíé *Balance ProCoin:*
‚Ä¢ Saldo disponible: {user_info[3]:.2f} PRC
‚Ä¢ Equivalente en CUP: {user_info[3] * cup_rate:,.0f} CUP

üè¶ *Valor total:* {user_info[3]:.2f} PRC
üíµ *Equivalente total CUP:* {user_info[3] * cup_rate:,.0f} CUP"""
    
    bot.edit_message_text(
        chat_id=call.message.chat.id,
        message_id=call.message.message_id,
        text=balance_text,
        parse_mode='Markdown',
        reply_markup=main_menu(call.message.chat.id)
    )

def show_current_rates(call_or_message):
    """Muestra las tasas actuales de cambio con todos los detalles"""
    # Obtener tasas
    cup_usd_rate = get_cup_usd_rate()
    
    # Para mostrar tambi√©n la tasa EUR que usamos para el c√°lculo
    try:
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        }
        response = requests.get(API_ENDPOINTS["eltoque"], headers=headers, timeout=5)
        soup = BeautifulSoup(response.content, 'html.parser')
        all_text = soup.get_text()
        
        eur_rate = None
        eur_pattern = r'1\s*EUR\s*[=‚âà]\s*([\d.,]+)\s*CUP'
        match = re.search(eur_pattern, all_text, re.IGNORECASE)
        if match:
            eur_rate = float(match.group(1).replace(',', ''))
    except:
        eur_rate = 540.0  # Valor por defecto

    eur_usd_rate = get_eur_usd_rate()
    
    rates_text = f"""
üìà *TASAS DE CAMBIO CALCULADAS*

üí∂ *Tasa Base (ElToque):*
‚Ä¢ 1 EUR = {eur_rate:,.0f} CUP

üí± *Tasa Internacional:*
‚Ä¢ 1 USD = {eur_usd_rate:.3f} EUR

üíµ *Tasa Calculada USD:*
‚Ä¢ 1 USD = {cup_usd_rate:,.0f} CUP
‚Ä¢ 1 PRC = {cup_usd_rate:,.0f} CUP

üìä *Conversiones comunes:*
‚Ä¢ 10 PRC = {10 * cup_usd_rate:,.0f} CUP
‚Ä¢ 50 PRC = {50 * cup_usd_rate:,.0f} CUP  
‚Ä¢ 100 PRC = {100 * cup_usd_rate:,.0f} CUP

üî¢ *C√°lculo:*
{eur_rate:,.0f} CUP/EUR √ó {eur_usd_rate:.3f} EUR/USD = {cup_usd_rate:,.0f} CUP/USD

üìÖ *Actualizado:* {datetime.now().strftime('%Y-%m-%d %H:%M')}"""

    if hasattr(call_or_message, 'message'):
        # Es un callback
        bot.edit_message_text(
            chat_id=call_or_message.message.chat.id,
            message_id=call_or_message.message.message_id,
            text=rates_text,
            parse_mode='Markdown',
            reply_markup=main_menu(call_or_message.message.chat.id)
        )
    else:
        # Es un mensaje
        bot.send_message(
            call_or_message.chat.id,
            rates_text,
            parse_mode='Markdown',
            reply_markup=main_menu(call_or_message.chat.id)
        )

# MANEJADOR DE CAPTURAS DE PANTALLA
@bot.message_handler(content_types=['photo'])
def handle_screenshot(message):
    user_id = message.from_user.id
    user_info = get_user_info(user_id)
    
    if user_id in pending_deposits:
        # Es un dep√≥sito CUP
        deposit_data = pending_deposits[user_id]
        deposit_id = deposit_data['deposit_id']
        amount_cup = deposit_data['amount_cup']
        amount_prc = deposit_data['amount_prc']
        method = deposit_data['method']
        
        photo_id = message.photo[-1].file_id
        
        conn = sqlite3.connect('cubawallet.db')
        cursor = conn.cursor()
        cursor.execute('UPDATE deposits SET screenshot_id = ? WHERE deposit_id = ?', (photo_id, deposit_id))
        conn.commit()
        conn.close()
        
        method_display = "Transferm√≥vil" if method == "transfermovil" else "EnZona"
        
        group_notification = f"""
üì• *NUEVO DEP√ìSITO CUP PENDIENTE* üì•

*Usuario:* {escape_markdown(user_info[2])}
*Wallet:* `{user_info[4]}`
*M√©todo:* {method_display}
*CUP depositados:* {amount_cup:,.0f} CUP
*ProCoin a recibir:* {amount_prc:.2f} PRC
*Tasa:* 1 PRC = {deposit_data['exchange_rate']:,.0f} CUP
*Dep√≥sito ID:* `{deposit_id}`

‚è≥ *Esperando verificaci√≥n...*

üíæ *Para aprobar usa:*
`/recargar {user_info[4]} {amount_prc}`"""
        
        send_group_notification(group_notification, photo_id=photo_id)
        
        bot.reply_to(message,
                    f"‚úÖ *Captura recibida*\n\n"
                    f"Hemos recibido tu comprobante por {amount_cup:,.0f} CUP\n\n"
                    f"üìä *Conversi√≥n:*\n"
                    f"‚Ä¢ CUP: {amount_cup:,.0f} CUP\n"
                    f"‚Ä¢ Tasa: 1 PRC = {deposit_data['exchange_rate']:,.0f} CUP\n"
                    f"‚Ä¢ ProCoin a recibir: {amount_prc:.2f} PRC\n\n"
                    f"üìã *Estado:* En revisi√≥n\n"
                    f"üÜî *Dep√≥sito:* {deposit_id}\n"
                    f"‚è∞ *Tiempo estimado:* 5-15 minutos\n\n"
                    f"Te notificaremos cuando sea verificado.",
                    parse_mode='Markdown',
                    reply_markup=main_menu(message.chat.id))
        
        del pending_deposits[user_id]

# FUNCIONES DE TRANSFERENCIA ENTRE USUARIOS
def process_recipient(message):
    recipient_address = message.text.strip()
    user_id = message.from_user.id
    user_info = get_user_info(user_id)
    
    # Verificar si la direcci√≥n existe
    recipient_info = get_user_by_wallet(recipient_address)
    
    if not recipient_info:
        bot.send_message(
            message.chat.id,
            "‚ùå *Direcci√≥n no encontrada*\n\nVerifica la direcci√≥n e intenta nuevamente.",
            parse_mode='Markdown',
            reply_markup=main_menu(message.chat.id)
        )
        return
    
    if recipient_info[0] == user_id:
        bot.send_message(
            message.chat.id,
            "‚ùå *No puedes enviarte ProCoin a ti mismo*",
            parse_mode='Markdown',
            reply_markup=main_menu(message.chat.id)
        )
        return
    
    bot.send_message(
        message.chat.id,
        f"‚úÖ *Destinatario encontrado:* {escape_markdown(recipient_info[2])}\n\nüíé Ingresa la cantidad de ProCoin a enviar:",
        parse_mode='Markdown'
    )
    
    bot.register_next_step_handler(message, process_amount, recipient_info)

def process_amount(message, recipient_info):
    try:
        amount = float(message.text)
        user_id = message.from_user.id
        user_info = get_user_info(user_id)
        
        if amount <= 0:
            bot.send_message(
                message.chat.id,
                "‚ùå *Monto inv√°lido*\nEl monto debe ser mayor a 0.",
                parse_mode='Markdown',
                reply_markup=main_menu(message.chat.id)
            )
            return
        
        if amount > user_info[3]:
            bot.send_message(
                message.chat.id,
                f"‚ùå *Saldo insuficiente*\n\nTu saldo: {user_info[3]:.2f} PRC\nMonto a enviar: {amount:.2f} PRC",
                parse_mode='Markdown',
                reply_markup=main_menu(message.chat.id)
            )
            return
        
        confirm_markup = types.InlineKeyboardMarkup()
        confirm_btn = types.InlineKeyboardButton("‚úÖ Confirmar Env√≠o", callback_data=f"confirm_send_{amount}_{recipient_info[0]}")
        cancel_btn = types.InlineKeyboardButton("‚ùå Cancelar", callback_data="cancel_send")
        confirm_markup.add(confirm_btn, cancel_btn)
        
        bot.send_message(
            message.chat.id,
            f"üîç *CONFIRMAR TRANSACCI√ìN*\n\n"
            f"üë§ *Destinatario:* {escape_markdown(recipient_info[2])}\n"
            f"üÜî *Wallet:* {recipient_info[4]}\n"
            f"üíé *Monto:* {amount:.2f} PRC\n\n"
            f"¬øConfirmas esta transacci√≥n?",
            parse_mode='Markdown',
            reply_markup=confirm_markup
        )
        
    except ValueError:
        bot.send_message(
            message.chat.id,
            "‚ùå *Formato inv√°lido*\nIngresa un n√∫mero v√°lido.",
            parse_mode='Markdown',
            reply_markup=main_menu(message.chat.id)
        )

@bot.callback_query_handler(func=lambda call: call.data.startswith('confirm_send_'))
def confirm_send(call):
    try:
        data_parts = call.data.split('_')
        amount = float(data_parts[2])
        recipient_id = int(data_parts[3])
        
        user_id = call.from_user.id
        user_info = get_user_info(user_id)
        recipient_info = get_user_info(recipient_id)
        
        if amount > user_info[3]:
            bot.answer_callback_query(call.id, "‚ùå Saldo insuficiente")
            return
        
        transaction_id = f"TXN{uuid.uuid4().hex[:10].upper()}"
        
        update_balance(user_id, -amount)
        update_balance(recipient_id, amount)
        
        log_transaction(transaction_id, user_id, recipient_id, amount, "transfer", "completed")
        
        success_text = f"""
‚úÖ *TRANSACCI√ìN EXITOSA*

üíé ProCoin enviados: {amount:.2f} PRC
üë§ Destinatario: {escape_markdown(recipient_info[2])}
üÜî Transacci√≥n: {transaction_id}
üìÖ Fecha: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

üí∞ Nuevo saldo: *{user_info[3] - amount:.2f} PRC*"""
        
        bot.edit_message_text(
            chat_id=call.message.chat.id,
            message_id=call.message.message_id,
            text=success_text,
            parse_mode='Markdown',
            reply_markup=main_menu(call.message.chat.id)
        )
        
        try:
            recipient_notification = f"""
üí∞ *HAS RECIBIDO PROCOIN*

üíé ProCoin recibidos: {amount:.2f} PRC
üë§ Remitente: {escape_markdown(user_info[2])}
üÜî Transacci√≥n: {transaction_id}

üí≥ Nuevo saldo: *{recipient_info[3] + amount:.2f} PRC*"""
            
            bot.send_message(
                chat_id=recipient_id,
                text=recipient_notification,
                parse_mode='Markdown'
            )
        except:
            pass
        
    except Exception as e:
        print(f"Error en transacci√≥n: {e}")
        bot.answer_callback_query(call.id, "‚ùå Error en la transacci√≥n")

@bot.callback_query_handler(func=lambda call: call.data == 'cancel_send')
def cancel_send(call):
    bot.edit_message_text(
        chat_id=call.message.chat.id,
        message_id=call.message.message_id,
        text="‚ùå *Transacci√≥n cancelada*",
        parse_mode='Markdown',
        reply_markup=main_menu(call.message.chat.id)
    )

# COMANDO PARA VER SALDO
@bot.message_handler(commands=['saldo'])
def show_balance_command(message):
    user_id = message.from_user.id
    user_info = get_user_info(user_id)
    
    if user_info:
        cup_rate = get_cup_usd_rate()
        bot.send_message(
            message.chat.id,
            f"üí∞ *Tu saldo actual:* {user_info[3]:.2f} PRC\nüíµ *Equivalente:* {user_info[3] * cup_rate:,.0f} CUP",
            parse_mode='Markdown',
            reply_markup=main_menu(message.chat.id)
        )

# INICIALIZACI√ìN Y EJECUCI√ìN
def run_bot():
    """Ejecuta el bot de Telegram en un hilo separado"""
    print("üß† Inicializando base de datos...")
    init_db()
    print("ü§ñ Iniciando bot ProCoin...")
    print(f"üëë Administrador: {ADMIN_ID}")
    print(f"üì¢ Notificaciones al grupo: {GROUP_CHAT_ID}")
    
    # Probar notificaciones al inicio
    test_msg = "üîî *Bot ProCoin iniciado* - Sistema con tasas en tiempo real activo"
    send_group_notification(test_msg)
    
    try:
        bot.polling(none_stop=True)
    except Exception as e:
        print(f"Error en el bot: {e}")
        time.sleep(10)
        run_bot()

if __name__ == "__main__":
    # Iniciar el bot en un hilo separado
    bot_thread = threading.Thread(target=run_bot)
    bot_thread.daemon = True
    bot_thread.start()
    
    # Iniciar el servidor web para Render
    port = int(os.environ.get("PORT", 5000))
    app.run(host='0.0.0.0', port=port)
