import telebot
from telebot import types
import sqlite3
import uuid
from datetime import datetime
import html
import re
import time
import os
import requests
import json
from bs4 import BeautifulSoup
import threading
import traceback

# Configuraci√≥n
TOKEN = "8400947960:AAGGXHezQbmUqk6AOpgT1GqMLaF-rMvVp9Y"
GROUP_CHAT_ID = "-4932107704"
ADMIN_ID = 1853800972
bot = telebot.TeleBot(TOKEN)

# Configuraci√≥n de la API ElToque
ELTOQUE_API_URL = "https://tasas.eltoque.com/v1/trmi"
ELTOQUE_API_TOKEN = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmcmVzaCI6ZmFsc2UsImlhdCI6MTc2MTE0NzQzMSwianRpIjoiMTc4ZGIyZWYtNWIzNy00MzJhLTkwYTktNTczZDBiOGE2N2ViIiwidHlwZSI6ImFjY2VzcyIsInN1YiI6IjY4ZjgyZjM1ZTkyYmU3N2VhMzAzODJhZiIsIm5iZiI6MTc2MTE0NzQzMSwiZXhwIjoxNzkyNjgzNDMxfQ.gTIXoSudOyo99vLLBap74_5UfdSRdOLluXekb0F1cPg"

# =============================================================================
# SISTEMA DE CACH√â MEJORADO - 1 MINUTO
# =============================================================================

# Variables globales para el cach√©
rates_cache = None
last_api_call = 0
CACHE_DURATION = 60  # 1 MINUTO - ACTUALIZADO

def get_eltoque_rates_cached():
    """
    Sistema de cach√© mejorado - actualizaci√≥n cada 1 minuto
    """
    global rates_cache, last_api_call
    
    current_time = time.time()
    
    # Si hay cach√© y no ha expirado, usarlo
    if rates_cache and (current_time - last_api_call) < CACHE_DURATION:
        print(f"‚úÖ Usando cach√© (edad: {current_time - last_api_call:.1f}s)")
        return rates_cache
    
    print("üîÑ Actualizando cach√© desde API...")
    
    # Obtener nuevas tasas
    new_rates = get_eltoque_rates()
    
    if new_rates:
        rates_cache = new_rates
        last_api_call = current_time
        print(f"‚úÖ Cach√© actualizado con {len(new_rates)} tasas")
        return rates_cache
    else:
        # Si la API falla pero tenemos cach√© anterior, usarlo
        if rates_cache:
            print("‚ö†Ô∏è API fall√≥, usando cach√© anterior")
            return rates_cache
        else:
            # Si no hay cach√© y la API falla, usar valores por defecto
            print("‚ö†Ô∏è Sin cach√© y API fall√≥, usando valores por defecto")
            default_rates = {
                'USD': 490,
                'USDT_TRC20': 517, 
                'MLC': 200,
                'ECU': 540,
                'BTC': 490,
                'TRX': 180
            }
            rates_cache = default_rates
            last_api_call = current_time
            return default_rates

def get_eltoque_rates():
    """
    Funci√≥n mejorada para obtener tasas de la API
    """
    try:
        today = datetime.now().strftime("%Y-%m-%d")
        params = {
            'date_from': f"{today} 00:00:01",
            'date_to': f"{today} 23:59:01"
        }
        
        headers = {
            'accept': '*/*',
            'Authorization': f'Bearer {ELTOQUE_API_TOKEN}',
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        }
        
        print("üîó Conectando a API ElToque...")
        response = requests.get(ELTOQUE_API_URL, params=params, headers=headers, timeout=10)
        
        if response.status_code != 200:
            print(f"‚ùå Error HTTP {response.status_code}")
            return None
            
        data = response.json()
        
        if 'tasas' not in data:
            print("‚ùå No se encontr√≥ campo 'tasas'")
            return None
        
        # Procesar tasas
        rates = {}
        for currency, rate in data['tasas'].items():
            try:
                rates[currency] = float(rate)
            except (ValueError, TypeError):
                continue
        
        if rates:
            print(f"‚úÖ {len(rates)} tasas obtenidas")
            return rates
        else:
            print("‚ùå No se pudieron procesar las tasas")
            return None
            
    except Exception as e:
        print(f"‚ùå Error en API: {e}")
        return None

def get_cup_usd_rate():
    """Obtiene tasa USD de forma robusta"""
    try:
        rates = get_eltoque_rates_cached()
        return rates.get('USD') or rates.get('USDT_TRC20', 490)
    except:
        return 490

def get_cup_eur_rate():
    """Obtiene tasa EUR de forma robusta"""
    try:
        rates = get_eltoque_rates_cached()
        return rates.get('ECU') or rates.get('EUR', 540)
    except:
        return 540

# =============================================================================
# FUNCIONES PRINCIPALES MEJORADAS
# =============================================================================

pending_deposits = {}
pending_withdrawals = {}
pending_sends = {}
pending_orders = {}

def send_group_notification(message, photo_id=None):
    """Env√≠a notificaci√≥n al grupo de forma segura"""
    try:
        if photo_id:
            bot.send_photo(GROUP_CHAT_ID, photo=photo_id, caption=message, parse_mode='Markdown')
        else:
            bot.send_message(GROUP_CHAT_ID, text=message, parse_mode='Markdown')
        return True
    except Exception as e:
        print(f"‚ùå Error enviando notificaci√≥n: {e}")
        return False

def init_db():
    """Inicializa la base de datos MEJORADA"""
    conn = sqlite3.connect('cubawallet.db', check_same_thread=False)
    cursor = conn.cursor()
    
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS users (
            user_id INTEGER PRIMARY KEY,
            username TEXT,
            first_name TEXT,
            balance REAL DEFAULT 0.0,
            wallet_address TEXT UNIQUE,
            registered_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
    ''')
    
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS transactions (
            transaction_id TEXT PRIMARY KEY,
            from_user INTEGER,
            to_user INTEGER,
            amount REAL,
            currency TEXT DEFAULT 'PRC',
            transaction_type TEXT,
            status TEXT,
            timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (from_user) REFERENCES users (user_id),
            FOREIGN KEY (to_user) REFERENCES users (user_id)
        )
    ''')
    
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS deposits (
            deposit_id TEXT PRIMARY KEY,
            user_id INTEGER,
            amount_cup REAL,
            amount_prc REAL,
            exchange_rate REAL,
            method TEXT,
            status TEXT,
            screenshot_id TEXT,
            admin_approved INTEGER,
            timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (user_id) REFERENCES users (user_id)
        )
    ''')
    
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS withdrawals (
            withdrawal_id TEXT PRIMARY KEY,
            user_id INTEGER,
            amount_prc REAL,
            amount_cup REAL,
            exchange_rate REAL,
            fee REAL,
            net_amount REAL,
            card_number TEXT,
            status TEXT,
            screenshot_id TEXT,
            admin_approved INTEGER,
            timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (user_id) REFERENCES users (user_id)
        )
    ''')
    
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS products (
            product_id TEXT PRIMARY KEY,
            name TEXT,
            description TEXT,
            price_prc REAL,
            category TEXT,
            image_url TEXT,
            is_available BOOLEAN DEFAULT TRUE,
            created_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
    ''')
    
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS orders (
            order_id TEXT PRIMARY KEY,
            user_id INTEGER,
            product_id TEXT,
            product_name TEXT,
            quantity INTEGER,
            total_price REAL,
            status TEXT DEFAULT 'pending',
            phone_number TEXT,
            order_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            delivery_date TIMESTAMP,
            FOREIGN KEY (user_id) REFERENCES users (user_id),
            FOREIGN KEY (product_id) REFERENCES products (product_id)
        )
    ''')
    
    # Insertar productos de ejemplo si no existen
    products_data = [
        ('NET-001', 'üåê Paquete 1GB Nauta', '1GB de datos para navegaci√≥n Nauta', 5.0, 'internet', '', 1),
        ('NET-002', 'üåê Paquete 3GB Nauta', '3GB de datos para navegaci√≥n Nauta', 12.0, 'internet', '', 1),
        ('NET-003', 'üåê Paquete 5GB Nauta', '5GB de datos para navegaci√≥n Nauta', 18.0, 'internet', '', 1),
        ('NET-004', 'üåê Paquete 10GB Nauta', '10GB de datos para navegaci√≥n Nauta', 30.0, 'internet', '', 1),
        ('GAM-001', 'üéÆ Steam $10', 'Tarjeta de regalo Steam $10 USD', 8.0, 'gaming', '', 1),
        ('GAM-002', 'üéÆ Xbox Live 1 Mes', 'Suscripci√≥n Xbox Live Gold 1 mes', 6.0, 'gaming', '', 1),
        ('GAM-003', 'üéÆ Nintendo $10', 'Tarjeta de regalo Nintendo eShop $10', 8.5, 'gaming', '', 1),
        ('SOF-001', 'üíª Windows 10 Pro', 'Licencia digital Windows 10 Professional', 15.0, 'software', '', 1),
        ('SOF-002', 'üíª Office 365 Personal', 'Suscripci√≥n Office 365 por 1 a√±o', 25.0, 'software', '', 1),
        ('SOF-003', 'üíª Antivirus Premium', 'Licencia antivirus premium 1 a√±o', 12.0, 'software', '', 1),
        ('OTH-001', 'üì± Recarga M√≥vil 100 CUP', 'Recarga de 100 CUP a n√∫mero m√≥vil', 4.0, 'other', '', 1),
        ('OTH-002', 'üì∫ Netflix Premium 1 Mes', 'Cuenta Netflix Premium 1 mes', 12.0, 'other', '', 1),
        ('OTH-003', 'üéµ Spotify Premium 1 Mes', 'Suscripci√≥n Spotify Premium 1 mes', 8.0, 'other', '', 1),
        ('OTH-004', 'üìπ YouTube Premium 1 Mes', 'Suscripci√≥n YouTube Premium 1 mes', 10.0, 'other', '', 1),
    ]
    
    for product in products_data:
        cursor.execute('''
            INSERT OR IGNORE INTO products (product_id, name, description, price_prc, category, image_url, is_available)
            VALUES (?, ?, ?, ?, ?, ?, ?)
        ''', product)
    
    conn.commit()
    conn.close()
    print("‚úÖ Base de datos inicializada y productos cargados")

def escape_markdown(text):
    """Escapa texto para Markdown V2 de forma correcta"""
    if text is None:
        return ""
    
    # Para MarkdownV2, estos son los caracteres que deben escaparse
    escape_chars = r'\_*[]()~`>#+-=|{}.!'
    
    # Escapar cada car√°cter especial
    escaped_text = str(text)
    for char in escape_chars:
        escaped_text = escaped_text.replace(char, f'\\{char}')
    
    return escaped_text

def is_admin(user_id):
    return user_id == ADMIN_ID

def generate_wallet_address():
    return f"PRC{uuid.uuid4().hex[:12].upper()}"

def register_user(user_id, username, first_name):
    conn = sqlite3.connect('cubawallet.db', check_same_thread=False)
    cursor = conn.cursor()
    
    cursor.execute('SELECT * FROM users WHERE user_id = ?', (user_id,))
    user = cursor.fetchone()
    
    if not user:
        wallet_address = generate_wallet_address()
        cursor.execute('''
            INSERT INTO users (user_id, username, first_name, wallet_address, balance)
            VALUES (?, ?, ?, ?, ?)
        ''', (user_id, username, first_name, wallet_address, 0.0))
        conn.commit()
        
        notification_text = f"""
üÜï *NUEVO USUARIO REGISTRADO* üÜï

*Informaci√≥n del usuario:*
‚Ä¢ *Nombre:* {escape_markdown(first_name)}
‚Ä¢ *Username:* @{escape_markdown(username) if username else 'N/A'}
‚Ä¢ *User ID:* `{user_id}`
‚Ä¢ *Wallet:* `{wallet_address}`

*¬°Bienvenido a la familia ProCoin\\!*"""
        
        send_group_notification(notification_text)
        print(f"‚úÖ Usuario registrado: {first_name}")
    
    conn.close()

def get_user_info(user_id):
    conn = sqlite3.connect('cubawallet.db', check_same_thread=False)
    cursor = conn.cursor()
    cursor.execute('SELECT * FROM users WHERE user_id = ?', (user_id,))
    user = cursor.fetchone()
    conn.close()
    return user

def get_user_by_wallet(wallet_address):
    conn = sqlite3.connect('cubawallet.db', check_same_thread=False)
    cursor = conn.cursor()
    cursor.execute('SELECT * FROM users WHERE wallet_address = ?', (wallet_address,))
    user = cursor.fetchone()
    conn.close()
    return user

def update_balance(user_id, amount):
    conn = sqlite3.connect('cubawallet.db', check_same_thread=False)
    cursor = conn.cursor()
    cursor.execute('UPDATE users SET balance = balance + ? WHERE user_id = ?', (amount, user_id))
    conn.commit()
    conn.close()

def log_transaction(transaction_id, from_user, to_user, amount, transaction_type, status):
    conn = sqlite3.connect('cubawallet.db', check_same_thread=False)
    cursor = conn.cursor()
    cursor.execute('''
        INSERT INTO transactions (transaction_id, from_user, to_user, amount, transaction_type, status)
        VALUES (?, ?, ?, ?, ?, ?)
    ''', (transaction_id, from_user, to_user, amount, transaction_type, status))
    conn.commit()
    conn.close()

def log_deposit(deposit_id, user_id, amount_cup, amount_prc, exchange_rate, method, status, screenshot_id=None):
    conn = sqlite3.connect('cubawallet.db', check_same_thread=False)
    cursor = conn.cursor()
    cursor.execute('''
        INSERT INTO deposits (deposit_id, user_id, amount_cup, amount_prc, exchange_rate, method, status, screenshot_id)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    ''', (deposit_id, user_id, amount_cup, amount_prc, exchange_rate, method, status, screenshot_id))
    conn.commit()
    conn.close()

def log_withdrawal(withdrawal_id, user_id, amount_prc, amount_cup, exchange_rate, fee, net_amount, card_number, status, screenshot_id=None):
    conn = sqlite3.connect('cubawallet.db', check_same_thread=False)
    cursor = conn.cursor()
    cursor.execute('''
        INSERT INTO withdrawals (withdrawal_id, user_id, amount_prc, amount_cup, exchange_rate, fee, net_amount, card_number, status, screenshot_id)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    ''', (withdrawal_id, user_id, amount_prc, amount_cup, exchange_rate, fee, net_amount, card_number, status, screenshot_id))
    conn.commit()
    conn.close()

def create_order(order_id, user_id, product_id, product_name, quantity, total_price, phone_number=None):
    conn = sqlite3.connect('cubawallet.db', check_same_thread=False)
    cursor = conn.cursor()
    cursor.execute('''
        INSERT INTO orders (order_id, user_id, product_id, product_name, quantity, total_price, phone_number)
        VALUES (?, ?, ?, ?, ?, ?, ?)
    ''', (order_id, user_id, product_id, product_name, quantity, total_price, phone_number))
    conn.commit()
    conn.close()

def update_order_status(order_id, status):
    conn = sqlite3.connect('cubawallet.db', check_same_thread=False)
    cursor = conn.cursor()
    if status == 'delivered':
        cursor.execute('UPDATE orders SET status = ?, delivery_date = CURRENT_TIMESTAMP WHERE order_id = ?', (status, order_id))
    else:
        cursor.execute('UPDATE orders SET status = ? WHERE order_id = ?', (status, order_id))
    conn.commit()
    conn.close()

def get_order_info(order_id):
    conn = sqlite3.connect('cubawallet.db', check_same_thread=False)
    cursor = conn.cursor()
    cursor.execute('''
        SELECT o.*, u.first_name, u.user_id 
        FROM orders o 
        JOIN users u ON o.user_id = u.user_id 
        WHERE o.order_id = ?
    ''', (order_id,))
    order = cursor.fetchone()
    conn.close()
    return order

# =============================================================================
# SISTEMA DE MEN√öS MEJORADO
# =============================================================================

def main_menu():
    """Men√∫ principal con dise√±o mejorado"""
    markup = types.ReplyKeyboardMarkup(row_width=2, resize_keyboard=True)
    
    btn_operations = types.KeyboardButton("üìä Operaciones")
    btn_shop = types.KeyboardButton("üõçÔ∏è Tienda")
    btn_help = types.KeyboardButton("‚ùì Ayuda")
    
    markup.add(btn_operations, btn_shop, btn_help)
    return markup

def operations_menu():
    """Men√∫ de operaciones"""
    markup = types.ReplyKeyboardMarkup(row_width=2, resize_keyboard=True)
    
    btn_send = types.KeyboardButton("üì§ Enviar")
    btn_receive = types.KeyboardButton("üì• Recibir")
    btn_deposit = types.KeyboardButton("üíµ Depositar")
    btn_withdraw = types.KeyboardButton("üí∏ Retirar")
    btn_balance = types.KeyboardButton("üí∞ Saldo")
    btn_rates = types.KeyboardButton("üìà Tasas")
    btn_back = types.KeyboardButton("üîô Men√∫ Principal")
    
    markup.add(btn_send, btn_receive, btn_deposit, btn_withdraw, btn_balance, btn_rates, btn_back)
    return markup

def shop_menu():
    """Men√∫ de la tienda"""
    markup = types.ReplyKeyboardMarkup(row_width=2, resize_keyboard=True)
    
    btn_internet = types.KeyboardButton("üåê Paquetes Internet")
    btn_gaming = types.KeyboardButton("üéÆ Juegos Digitales")
    btn_software = types.KeyboardButton("üíª Software")
    btn_other = types.KeyboardButton("üì± Otros Productos")
    btn_back = types.KeyboardButton("üîô Men√∫ Principal")
    
    markup.add(btn_internet, btn_gaming, btn_software, btn_other, btn_back)
    return markup

def deposit_methods_menu():
    """Men√∫ de m√©todos de dep√≥sito"""
    markup = types.ReplyKeyboardMarkup(row_width=2, resize_keyboard=True)
    
    btn_transfermovil = types.KeyboardButton("üì± Transferm√≥vil")
    btn_enzona = types.KeyboardButton("üîµ EnZona")
    btn_back = types.KeyboardButton("üîô Atr√°s")
    
    markup.add(btn_transfermovil, btn_enzona, btn_back)
    return markup

# =============================================================================
# MANEJADORES DE MENSAJES MEJORADOS
# =============================================================================

@bot.message_handler(commands=['start'])
def send_welcome(message):
    try:
        user_id = message.from_user.id
        username = message.from_user.username
        first_name = message.from_user.first_name
        
        register_user(user_id, username, first_name)
        user_info = get_user_info(user_id)
        
        cup_rate = get_cup_usd_rate()
        
        welcome_text = f"""
üéâ *¬°Bienvenido a ProCoin, {escape_markdown(first_name)}!* üéâ

üíé *Tu Billetera Digital Cubana*

üìä *Resumen de tu cuenta:*
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚îÇ üë§ *Usuario:* {escape_markdown(first_name)}
‚îÇ üíº *Wallet:* `{user_info[4]}`
‚îÇ üí∞ *Saldo:* {user_info[3]:.2f} PRC
‚îÇ üíµ *Equivalente:* {user_info[3] * cup_rate:,.0f} CUP
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

üí± *Tasa actual:* 1 PRC = {cup_rate:,.0f} CUP

üåü *Selecciona una opci√≥n del men√∫:*"""
        
        bot.send_message(
            chat_id=message.chat.id,
            text=welcome_text,
            parse_mode='Markdown',
            reply_markup=main_menu()
        )
    except Exception as e:
        print(f"‚ùå Error en start: {e}")
        bot.send_message(message.chat.id, "‚ùå Error al iniciar. Intenta nuevamente.")

@bot.message_handler(func=lambda message: message.text == "üìä Operaciones")
def show_operations(message):
    """Muestra el men√∫ de operaciones"""
    operations_text = """
‚ö° *MEN√ö DE OPERACIONES* ‚ö°

Selecciona la operaci√≥n que deseas realizar:

üì§ *Enviar* - Transferir ProCoin a otros usuarios
üì• *Recibir* - Obtener tu direcci√≥n para recibir pagos
üíµ *Depositar* - Convertir CUP a ProCoin
üí∏ *Retirar* - Convertir ProCoin a CUP
üí∞ *Saldo* - Consultar tu balance actual
üìà *Tasas* - Ver tasas de cambio actualizadas

üëá *Elige una opci√≥n:*"""
    
    bot.send_message(
        message.chat.id,
        operations_text,
        parse_mode='Markdown',
        reply_markup=operations_menu()
    )

@bot.message_handler(func=lambda message: message.text == "üõçÔ∏è Tienda")
def show_shop(message):
    """Muestra el men√∫ de la tienda"""
    shop_text = """
üõçÔ∏è *TIENDA PROCOIN* üõçÔ∏è

¬°Bienvenido a nuestra tienda digital! Aqu√≠ puedes adquirir productos y servicios usando tus ProCoin.

üì¶ *Categor√≠as disponibles:*

üåê *Paquetes Internet* - Recargas y paquetes de datos
üéÆ *Juegos Digitales* - Claves y suscripciones gaming
üíª *Software* - Licencias y programas
üì± *Otros Productos* - Variedad de productos digitales

üëá *Selecciona una categor√≠a:*"""
    
    bot.send_message(
        message.chat.id,
        shop_text,
        parse_mode='Markdown',
        reply_markup=shop_menu()
    )

@bot.message_handler(func=lambda message: message.text == "‚ùì Ayuda")
def show_help(message):
    """Muestra ayuda"""
    help_text = """
‚ùì *CENTRO DE AYUDA* ‚ùì

*Preguntas Frecuentes:*

ü§î *¬øQu√© es ProCoin?*
ProCoin es una moneda digital cubana respaldada por tasas reales del mercado.

üí≥ *¬øC√≥mo puedo depositar?*
Usa la opci√≥n \"Depositar\" y sigue las instrucciones para Transferm√≥vil o EnZona.

üì§ *¬øC√≥mo env√≠o ProCoin?*
Ve a \"Operaciones\" ‚Üí \"Enviar\" e ingresa la wallet del destinatario.

üõçÔ∏è *¬øQu√© puedo comprar en la tienda?*
Paquetes de internet, juegos, software y diversos productos digitales.

üìû *Soporte T√©cnico:*
@TuUsuarioDeSoporte

‚ö†Ô∏è *Recuerda:* Nunca compartas tu clave privada."""
    
    bot.send_message(
        message.chat.id,
        help_text,
        parse_mode='Markdown',
        reply_markup=main_menu()
    )

@bot.message_handler(func=lambda message: message.text == "üîô Men√∫ Principal")
def back_to_main(message):
    """Vuelve al men√∫ principal"""
    user_info = get_user_info(message.from_user.id)
    cup_rate = get_cup_usd_rate()
    
    main_text = f"""
üè† *MEN√ö PRINCIPAL* üè†

üìä *Resumen r√°pido:*
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚îÇ üí∞ *Saldo:* {user_info[3]:.2f} PRC
‚îÇ üíµ *Equivalente:* {user_info[3] * cup_rate:,.0f} CUP
‚îÇ üí± *Tasa:* 1 PRC = {cup_rate:,.0f} CUP
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

üëá *Selecciona una opci√≥n:*"""
    
    bot.send_message(
        message.chat.id,
        main_text,
        parse_mode='Markdown',
        reply_markup=main_menu()
    )

@bot.message_handler(func=lambda message: message.text == "üîô Atr√°s")
def back_to_operations(message):
    """Vuelve al men√∫ de operaciones"""
    show_operations(message)

# =============================================================================
# OPERACIONES PRINCIPALES - CORREGIDAS Y MEJORADAS
# =============================================================================

@bot.message_handler(func=lambda message: message.text == "üí∞ Saldo")
def show_balance(message):
    """Muestra el saldo del usuario"""
    try:
        user_id = message.from_user.id
        user_info = get_user_info(user_id)
        cup_rate = get_cup_usd_rate()
        
        balance_text = f"""
üí∞ *CONSULTA DE SALDO* üí∞

üìä *Detalles de tu cuenta:*
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚îÇ üë§ *Usuario:* {escape_markdown(user_info[2])}
‚îÇ üíº *Wallet:* `{user_info[4]}`
‚îÇ üíé *ProCoin:* {user_info[3]:.2f} PRC
‚îÇ üíµ *Equivalente:* {user_info[3] * cup_rate:,.0f} CUP
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

üí± *Tasa de cambio:* 1 PRC = {cup_rate:,.0f} CUP

üí° *¬øNecesitas m√°s ProCoin?*
Usa la opci√≥n \"Depositar\" para agregar fondos."""
        
        bot.send_message(
            message.chat.id,
            balance_text,
            parse_mode='Markdown',
            reply_markup=operations_menu()
        )
    except Exception as e:
        print(f"‚ùå Error en saldo: {e}")
        bot.send_message(message.chat.id, "‚ùå Error al consultar saldo.")

@bot.message_handler(func=lambda message: message.text == "üìà Tasas")
def show_rates(message):
    """Muestra las tasas actuales CORREGIDAS"""
    show_current_rates(message)

@bot.message_handler(func=lambda message: message.text == "üì• Recibir")
def show_receive_info(message):
    """Muestra informaci√≥n para recibir pagos"""
    try:
        user_id = message.from_user.id
        user_info = get_user_info(user_id)
        
        receive_text = f"""
üì• *RECIBIR PROCOIN* üì•

üíº *Tu direcci√≥n √∫nica:*
`{user_info[4]}`

üìã *Para recibir pagos:*
1Ô∏è‚É£ Comparte esta direcci√≥n con quien te enviar√° ProCoin
2Ô∏è‚É£ El remitente usa la opci√≥n \"Enviar\"
3Ô∏è‚É£ Ingresa tu direcci√≥n √∫nica
4Ô∏è‚É£ ¬°Recibes los fondos al instante!

üí° *Consejo:* Mant√©n esta direcci√≥n segura y comp√°rtela solo con personas de confianza.

‚ö†Ô∏è *Solo acepta pagos en ProCoin*"""
        
        bot.send_message(
            message.chat.id,
            receive_text,
            parse_mode='Markdown',
            reply_markup=operations_menu()
        )
    except Exception as e:
        print(f"‚ùå Error en recibir: {e}")
        bot.send_message(message.chat.id, "‚ùå Error al cargar informaci√≥n.")

# =============================================================================
# SISTEMA DE ENV√çO DE DINERO - CORREGIDO Y FUNCIONAL
# =============================================================================

@bot.message_handler(func=lambda message: message.text == "üì§ Enviar")
def start_send_money(message):
    """Inicia el proceso de enviar dinero - CORREGIDO"""
    try:
        user_id = message.from_user.id
        user_info = get_user_info(user_id)
        
        if user_info[3] <= 0:
            bot.send_message(
                message.chat.id,
                "‚ùå *No tienes saldo suficiente para enviar.*\n\n"
                "üí° *Sugerencia:* Recarga tu cuenta en la opci√≥n \"Depositar\".",
                parse_mode='Markdown',
                reply_markup=operations_menu()
            )
            return
        
        msg = bot.send_message(
            message.chat.id,
            "üì§ *ENVIAR PROCOIN*\n\n"
            "üíº *Ingresa la direcci√≥n wallet del destinatario:*\n\n"
            "üí° *Ejemplo:* `PRCABC123DEF456`",
            parse_mode='Markdown'
        )
        bot.register_next_step_handler(msg, process_receiver_wallet)
    except Exception as e:
        print(f"‚ùå Error en enviar: {e}")
        bot.send_message(message.chat.id, "‚ùå Error al iniciar env√≠o.")

def process_receiver_wallet(message):
    """Procesa la wallet del destinatario"""
    try:
        user_id = message.from_user.id
        receiver_wallet = message.text.strip()
        
        # Validar formato de wallet
        if not receiver_wallet.startswith('PRC') or len(receiver_wallet) != 15:
            bot.send_message(
                message.chat.id,
                "‚ùå *Formato de wallet inv√°lido.*\n\n"
                "üí° *Aseg√∫rate de que:*\n"
                "- Comienza con 'PRC'\n"
                "- Tiene 15 caracteres\n\n"
                "*Ejemplo:* `PRCABC123DEF456`",
                parse_mode='Markdown',
                reply_markup=operations_menu()
            )
            return
        
        # Verificar que no sea la propia wallet
        user_info = get_user_info(user_id)
        if receiver_wallet == user_info[4]:
            bot.send_message(
                message.chat.id,
                "‚ùå *No puedes enviarte ProCoin a ti mismo.*",
                parse_mode='Markdown',
                reply_markup=operations_menu()
            )
            return
        
        # Verificar que la wallet exista
        receiver_info = get_user_by_wallet(receiver_wallet)
        if not receiver_info:
            bot.send_message(
                message.chat.id,
                "‚ùå *Wallet no encontrada.*\n\n"
                "üí° *Verifica la direcci√≥n e intenta nuevamente.*",
                parse_mode='Markdown',
                reply_markup=operations_menu()
            )
            return
        
        # Guardar temporalmente la wallet del receptor
        pending_sends[user_id] = {'receiver_wallet': receiver_wallet, 'receiver_id': receiver_info[0]}
        
        msg = bot.send_message(
            message.chat.id,
            f"üë§ *Destinatario:* {escape_markdown(receiver_info[2])}\n"
            f"üíº *Wallet:* `{receiver_wallet}`\n\n"
            "üíé *Ingresa el monto de ProCoin a enviar:*",
            parse_mode='Markdown'
        )
        bot.register_next_step_handler(msg, process_send_amount)
    except Exception as e:
        print(f"‚ùå Error procesando wallet: {e}")
        bot.send_message(message.chat.id, "‚ùå Error al procesar wallet.")

def process_send_amount(message):
    """Procesa el monto a enviar"""
    try:
        user_id = message.from_user.id
        user_info = get_user_info(user_id)
        
        # Validar monto
        try:
            amount = float(message.text.replace(',', '.'))
        except:
            bot.send_message(
                message.chat.id,
                "‚ùå *Formato inv√°lido.*\n\n"
                "üí° *Ingresa un n√∫mero v√°lido.*\n"
                "*Ejemplo:* 10.50",
                parse_mode='Markdown',
                reply_markup=operations_menu()
            )
            return
        
        if amount <= 0:
            bot.send_message(
                message.chat.id,
                "‚ùå *El monto debe ser mayor a 0.*",
                parse_mode='Markdown',
                reply_markup=operations_menu()
            )
            return
        
        if user_info[3] < amount:
            bot.send_message(
                message.chat.id,
                f"‚ùå *Saldo insuficiente.*\n\n"
                f"üíé *Saldo actual:* {user_info[3]:.2f} PRC\n"
                f"üí∏ *Monto a enviar:* {amount:.2f} PRC",
                parse_mode='Markdown',
                reply_markup=operations_menu()
            )
            return
        
        # Obtener datos del receptor
        transfer_data = pending_sends.get(user_id)
        if not transfer_data:
            bot.send_message(
                message.chat.id,
                "‚ùå *Sesi√≥n expirada.*\n\n"
                "üí° *Vuelve a iniciar el proceso.*",
                parse_mode='Markdown',
                reply_markup=operations_menu()
            )
            return
        
        receiver_id = transfer_data['receiver_id']
        receiver_info = get_user_info(receiver_id)
        
        # Realizar transferencia
        update_balance(user_id, -amount)
        update_balance(receiver_id, amount)
        
        transaction_id = f"TXN{uuid.uuid4().hex[:8].upper()}"
        log_transaction(transaction_id, user_id, receiver_id, amount, "send_money", "completed")
        
        # Notificar al remitente
        bot.send_message(
            message.chat.id,
            f"‚úÖ *¬°Env√≠o exitoso!*\n\n"
            f"üì§ *Has enviado:* {amount:.2f} PRC\n"
            f"üë§ *A:* {escape_markdown(receiver_info[2])}\n"
            f"üíº *Wallet:* `{receiver_info[4]}`\n"
            f"üìã *Transacci√≥n:* `{transaction_id}`\n\n"
            f"üíé *Nuevo saldo:* {user_info[3] - amount:.2f} PRC",
            parse_mode='Markdown',
            reply_markup=operations_menu()
        )
        
        # Notificar al destinatario
        try:
            bot.send_message(
                receiver_id,
                f"‚úÖ *¬°Has recibido ProCoin!*\n\n"
                f"üì• *Has recibido:* {amount:.2f} PRC\n"
                f"üë§ *De:* {escape_markdown(user_info[2])}\n"
                f"üíº *Wallet:* `{user_info[4]}`\n"
                f"üìã *Transacci√≥n:* `{transaction_id}`\n\n"
                f"üíé *Nuevo saldo:* {receiver_info[3] + amount:.2f} PRC",
                parse_mode='Markdown'
            )
        except Exception as e:
            print(f"No se pudo notificar al destinatario: {e}")
        
        # Notificar al grupo
        send_group_notification(
            f"üì§ *NUEVA TRANSFERENCIA*\n\n"
            f"üë§ *De:* {escape_markdown(user_info[2])}\n"
            f"üë§ *Para:* {escape_markdown(receiver_info[2])}\n"
            f"üíé *Monto:* {amount:.2f} PRC\n"
            f"üìã *Transacci√≥n:* `{transaction_id}`"
        )
        
        # Limpiar transferencia pendiente
        if user_id in pending_sends:
            del pending_sends[user_id]
            
    except Exception as e:
        print(f"‚ùå Error enviando dinero: {e}")
        bot.send_message(message.chat.id, "‚ùå Error al procesar el env√≠o.")

# =============================================================================
# SISTEMA DE RETIRO DE DINERO - CORREGIDO Y FUNCIONAL
# =============================================================================

@bot.message_handler(func=lambda message: message.text == "üí∏ Retirar")
def start_withdraw(message):
    """Inicia el proceso de retiro - CORREGIDO"""
    try:
        user_id = message.from_user.id
        user_info = get_user_info(user_id)
        cup_rate = get_cup_usd_rate()
        
        if user_info[3] <= 0:
            bot.send_message(
                message.chat.id,
                "‚ùå *No tienes saldo suficiente para retirar.*\n\n"
                "üí° *Sugerencia:* Recarga tu cuenta en la opci√≥n \"Depositar\".",
                parse_mode='Markdown',
                reply_markup=operations_menu()
            )
            return
        
        withdrawal_text = f"""
üí∏ *RETIRAR PROCOIN*

üí± *Tasa actual:* 1 PRC = {cup_rate:,.0f} CUP
üí∞ *Saldo disponible:* {user_info[3]:.2f} PRC

üí≥ *Ingresa tu n√∫mero de tarjeta para recibir el pago:*
*Formato:* 9200123456789012

‚ö†Ô∏è *Aseg√∫rate de que la tarjeta est√© a tu nombre.*"""
        
        msg = bot.send_message(
            message.chat.id,
            withdrawal_text,
            parse_mode='Markdown'
        )
        bot.register_next_step_handler(msg, process_withdraw_card)
    except Exception as e:
        print(f"‚ùå Error en retiro: {e}")
        bot.send_message(message.chat.id, "‚ùå Error al iniciar retiro.")

def process_withdraw_card(message):
    """Procesa el n√∫mero de tarjeta para retiro"""
    try:
        user_id = message.from_user.id
        card_number = message.text.strip()
        
        # Validar n√∫mero de tarjeta (16 d√≠gitos)
        if not card_number.isdigit() or len(card_number) != 16:
            bot.send_message(
                message.chat.id,
                "‚ùå *N√∫mero de tarjeta inv√°lido.*\n\n"
                "üí° *Aseg√∫rate de:*\n"
                "- Ingresar 16 d√≠gitos\n"
                "- Solo n√∫meros, sin espacios\n\n"
                "*Ejemplo:* 9200123456789012",
                parse_mode='Markdown',
                reply_markup=operations_menu()
            )
            return
        
        # Guardar temporalmente el n√∫mero de tarjeta
        pending_withdrawals[user_id] = {'card_number': card_number}
        
        msg = bot.send_message(
            message.chat.id,
            "üíé *Ingresa el monto en ProCoin a retirar:*",
            parse_mode='Markdown'
        )
        bot.register_next_step_handler(msg, process_withdraw_amount)
    except Exception as e:
        print(f"‚ùå Error procesando tarjeta: {e}")
        bot.send_message(message.chat.id, "‚ùå Error al procesar tarjeta.")

def process_withdraw_amount(message):
    """Procesa el monto a retirar"""
    try:
        user_id = message.from_user.id
        user_info = get_user_info(user_id)
        
        # Validar monto
        try:
            amount_prc = float(message.text.replace(',', '.'))
        except:
            bot.send_message(
                message.chat.id,
                "‚ùå *Formato inv√°lido.*\n\n"
                "üí° *Ingresa un n√∫mero v√°lido.*\n"
                "*Ejemplo:* 10.50",
                parse_mode='Markdown',
                reply_markup=operations_menu()
            )
            return
        
        if amount_prc <= 0:
            bot.send_message(
                message.chat.id,
                "‚ùå *El monto debe ser mayor a 0.*",
                parse_mode='Markdown',
                reply_markup=operations_menu()
            )
            return
        
        if user_info[3] < amount_prc:
            bot.send_message(
                message.chat.id,
                f"‚ùå *Saldo insuficiente.*\n\n"
                f"üíé *Saldo actual:* {user_info[3]:.2f} PRC\n"
                f"üí∏ *Monto a retirar:* {amount_prc:.2f} PRC",
                parse_mode='Markdown',
                reply_markup=operations_menu()
            )
            return
        
        # Obtener datos temporales
        withdraw_data = pending_withdrawals.get(user_id)
        if not withdraw_data:
            bot.send_message(
                message.chat.id,
                "‚ùå *Sesi√≥n expirada.*\n\n"
                "üí° *Vuelve a iniciar el proceso.*",
                parse_mode='Markdown',
                reply_markup=operations_menu()
            )
            return
        
        card_number = withdraw_data['card_number']
        cup_rate = get_cup_usd_rate()
        
        # Calcular montos
        amount_cup = amount_prc * cup_rate
        fee = max(amount_cup * 0.05, 50)  # 5% comisi√≥n, m√≠nimo 50 CUP
        net_amount = amount_cup - fee
        
        if net_amount <= 0:
            bot.send_message(
                message.chat.id,
                "‚ùå *El monto a retirar es demasiado bajo despu√©s de la comisi√≥n.*",
                parse_mode='Markdown',
                reply_markup=operations_menu()
            )
            return
        
        # Actualizar saldo
        update_balance(user_id, -amount_prc)
        
        # Registrar retiro
        withdrawal_id = f"WD{uuid.uuid4().hex[:8].upper()}"
        log_withdrawal(withdrawal_id, user_id, amount_prc, amount_cup, cup_rate, fee, net_amount, card_number, "pending")
        
        # Notificar al usuario
        bot.send_message(
            message.chat.id,
            f"‚úÖ *Solicitud de retiro recibida.*\n\n"
            f"üìã *Resumen de retiro:*\n"
            f"‚Ä¢ ProCoin retirados: {amount_prc:.2f} PRC\n"
            f"‚Ä¢ Tasa: 1 PRC = {cup_rate:,.0f} CUP\n"
            f"‚Ä¢ Total CUP: {amount_cup:,.0f} CUP\n"
            f"‚Ä¢ Comisi√≥n: {fee:,.0f} CUP\n"
            f"‚Ä¢ Neto a recibir: {net_amount:,.0f} CUP\n"
            f"‚Ä¢ Tarjeta: {card_number[-4:]}\n"
            f"‚Ä¢ ID: {withdrawal_id}\n\n"
            f"‚è∞ *Tiempo de procesamiento:* 1-24 horas\n"
            f"üìû *Te notificaremos cuando sea completado.*",
            parse_mode='Markdown',
            reply_markup=operations_menu()
        )
        
        # Notificar al grupo
        group_notification = f"""
üí∏ *NUEVA SOLICITUD DE RETIRO*

üë§ *Usuario:* {escape_markdown(user_info[2])}
üíº *Wallet:* `{user_info[4]}`
üíé *ProCoin:* {amount_prc:.2f} PRC
üíµ *CUP a recibir:* {net_amount:,.0f} CUP
üí≥ *Tarjeta:* {card_number[-4:]}
üìã *Retiro ID:* `{withdrawal_id}`

‚è≥ *Esperando aprobaci√≥n...*

‚úÖ *Para aprobar usa:*
`/aprobar_retiro {withdrawal_id}`"""
        
        send_group_notification(group_notification)
        
        # Limpiar retiro pendiente
        if user_id in pending_withdrawals:
            del pending_withdrawals[user_id]
            
    except Exception as e:
        print(f"‚ùå Error retirando dinero: {e}")
        bot.send_message(message.chat.id, "‚ùå Error al procesar el retiro.")

# =============================================================================
# SISTEMA DE TASAS MEJORADO - CORREGIDO
# =============================================================================

def show_current_rates(message):
    """Muestra tasas de forma confiable y est√©tica - CORREGIDO"""
    try:
        print("üîç Obteniendo tasas para mostrar...")
        
        # Obtener tasas del cach√©
        all_rates = get_eltoque_rates_cached()
        
        if not all_rates:
            error_msg = "‚ùå *No se pudieron obtener las tasas*\n\nPor favor, intenta nuevamente en unos minutos."
            raise Exception("No se pudieron obtener tasas")
        
        # Usar USD o USDT como tasa principal
        main_rate = all_rates.get('USD') or all_rates.get('USDT_TRC20') or 490
        
        # Construir mensaje de forma est√©tica
        rates_text = f"""
üìà *TASAS DE CAMBIO ACTUALES* üìà

üíé *Tasa Principal ProCoin:*
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚îÇ 1 PRC = {main_rate:,} CUP
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

üí± *Todas las Tasas Disponibles:*
"""
        
        # Agregar todas las tasas ordenadas
        for currency, rate in sorted(all_rates.items()):
            rates_text += f"‚Ä¢ {currency}: {rate:,} CUP\n"
        
        # Conversiones comunes
        rates_text += f"""
üìä *Conversiones ProCoin:*
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚îÇ 10 PRC = {10 * main_rate:,} CUP
‚îÇ 50 PRC = {50 * main_rate:,} CUP  
‚îÇ 100 PRC = {100 * main_rate:,} CUP
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

üîÑ *Actualizado:* {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
‚è∞ *Pr√≥xima actualizaci√≥n:* 1 minuto"""
        
        print("‚úÖ Mensaje de tasas construido correctamente")
        
        bot.send_message(
            message.chat.id,
            rates_text,
            parse_mode='Markdown',
            reply_markup=operations_menu()
        )
            
    except Exception as e:
        print(f"‚ùå Error mostrando tasas: {e}")
        error_text = "‚ùå *Error temporal al obtener tasas*\n\nüîß El equipo ha sido notificado.\nüîÑ Intenta nuevamente en unos minutos."
        
        bot.send_message(
            message.chat.id,
            error_text,
            parse_mode='Markdown',
            reply_markup=operations_menu()
        )

# =============================================================================
# SISTEMA DE DEP√ìSITOS MEJORADO
# =============================================================================

@bot.message_handler(func=lambda message: message.text == "üíµ Depositar")
def show_deposit_options(message):
    """Muestra opciones de dep√≥sito"""
    try:
        user_id = message.from_user.id
        user_info = get_user_info(user_id)
        cup_rate = get_cup_usd_rate()
        
        deposit_text = f"""
üíµ *DEPOSITAR FONDOS* üíµ

üí± *Tasa actual:* 1 PRC = {cup_rate:,.0f} CUP

üìä *Tu saldo actual:* {user_info[3]:.2f} PRC

üí° *Proceso de dep√≥sito:*
1Ô∏è‚É£ Seleccionas m√©todo de pago
2Ô∏è‚É£ Realizas transferencia en CUP
3Ô∏è‚É£ Env√≠as el comprobante
4Ô∏è‚É£ Recibes ProCoin autom√°ticamente

üëá *Selecciona tu m√©todo de pago:*"""
        
        bot.send_message(
            message.chat.id,
            deposit_text,
            parse_mode='Markdown',
            reply_markup=deposit_methods_menu()
        )
    except Exception as e:
        print(f"‚ùå Error en dep√≥sito: {e}")
        bot.send_message(message.chat.id, "‚ùå Error al procesar dep√≥sito.")

@bot.message_handler(func=lambda message: message.text in ["üì± Transferm√≥vil", "üîµ EnZona"])
def handle_deposit_method(message):
    """Maneja la selecci√≥n del m√©todo de dep√≥sito"""
    try:
        method = "transfermovil" if message.text == "üì± Transferm√≥vil" else "enzona"
        start_cup_deposit(message, method)
    except Exception as e:
        print(f"‚ùå Error en m√©todo dep√≥sito: {e}")
        bot.send_message(message.chat.id, "‚ùå Error al seleccionar m√©todo.")

def start_cup_deposit(message, method):
    """Inicia el proceso de dep√≥sito"""
    try:
        cup_rate = get_cup_usd_rate()
        method_name = "Transferm√≥vil" if method == "transfermovil" else "EnZona"
        
        msg = bot.send_message(
            message.chat.id,
            f"üíµ *DEP√ìSITO POR {method_name}* üíµ\n\n"
            f"üí± *Tasa actual:* 1 PRC = {cup_rate:,.0f} CUP\n\n"
            f"üíµ *Ingresa el monto en CUP que deseas depositar:*\n\n"
            f"üí° *Ejemplo:* 1000, 5000, 10000",
            parse_mode='Markdown'
        )
        bot.register_next_step_handler(msg, process_cup_deposit_amount, method)
    except Exception as e:
        print(f"‚ùå Error iniciando dep√≥sito: {e}")
        bot.send_message(message.chat.id, "‚ùå Error al iniciar dep√≥sito.")

def process_cup_deposit_amount(message, method):
    """Procesa el monto del dep√≥sito"""
    try:
        user_id = message.from_user.id
        
        # Validar monto
        try:
            amount_cup = float(message.text.replace(',', '.'))
        except:
            bot.send_message(
                message.chat.id,
                "‚ùå *Formato inv√°lido*\nIngresa un n√∫mero v√°lido.\n\n*Ejemplos:* 1000, 2500.50, 5000",
                parse_mode='Markdown',
                reply_markup=operations_menu()
            )
            return
        
        if amount_cup <= 0:
            bot.send_message(
                message.chat.id,
                "‚ùå *Monto inv√°lido*\nEl monto debe ser mayor a 0.",
                parse_mode='Markdown',
                reply_markup=operations_menu()
            )
            return
        
        if amount_cup < 100:
            bot.send_message(
                message.chat.id,
                "‚ùå *Monto muy bajo*\nEl dep√≥sito m√≠nimo es 100 CUP.",
                parse_mode='Markdown',
                reply_markup=operations_menu()
            )
            return
        
        # Calcular conversi√≥n
        cup_rate = get_cup_usd_rate()
        amount_prc = amount_cup / cup_rate
        
        # Guardar dep√≥sito pendiente
        deposit_id = f"DEP{uuid.uuid4().hex[:8].upper()}"
        pending_deposits[user_id] = {
            'deposit_id': deposit_id,
            'amount_cup': amount_cup,
            'amount_prc': amount_prc,
            'exchange_rate': cup_rate,
            'method': method
        }
        
        # Mostrar instrucciones
        if method == "transfermovil":
            payment_text = f"""
üì± *INSTRUCCIONES TRANSFERM√ìVIL* üì±

üí≥ *Informaci√≥n para transferir:*
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚îÇ üìû *Tel√©fono:* `5351234567`
‚îÇ üë§ *Nombre:* ProCoin Exchange
‚îÇ üí∞ *Monto:* *{amount_cup:,.0f} CUP*
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

üìä *Conversi√≥n a ProCoin:*
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚îÇ CUP depositados: {amount_cup:,.0f} CUP
‚îÇ Tasa: 1 PRC = {cup_rate:,.0f} CUP
‚îÇ Recibir√°s: *{amount_prc:.2f} PRC*
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

üìã *Pasos a seguir:*
1Ô∏è‚É£ Abre Transferm√≥vil
2Ô∏è‚É£ Selecciona *Transferir*
3Ô∏è‚É£ Ingresa tel√©fono: *5351234567*
4Ô∏è‚É£ Monto: *{amount_cup:,.0f} CUP*
5Ô∏è‚É£ Confirma transferencia
6Ô∏è‚É£ Toma captura del comprobante
7Ô∏è‚É£ Env√≠ala en el siguiente mensaje

‚ö†Ô∏è *Importante:* 
‚Ä¢ Monto exacto: {amount_cup:,.0f} CUP
‚Ä¢ Solo transferencias propias
‚Ä¢ Verificaci√≥n: 5-15 minutos"""
        else:
            payment_text = f"""
üîµ *INSTRUCCIONES ENZONA* üîµ

üí≥ *Informaci√≥n para pagar:*
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚îÇ üë§ *Nombre:* ProCoin Exchange
‚îÇ üí∞ *Monto:* *{amount_cup:,.0f} CUP*
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

üìä *Conversi√≥n a ProCoin:*
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚îÇ CUP depositados: {amount_cup:,.0f} CUP
‚îÇ Tasa: 1 PRC = {cup_rate:,.0f} CUP
‚îÇ Recibir√°s: *{amount_prc:.2f} PRC*
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

üìã *Pasos a seguir:*
1Ô∏è‚É£ Abre EnZona
2Ô∏è‚É£ Busca *ProCoin Exchange*
3Ô∏è‚É£ Monto: *{amount_cup:,.0f} CUP*
4Ô∏è‚É£ Realiza el pago
5Ô∏è‚É£ Toma captura del comprobante
6Ô∏è‚É£ Env√≠ala en el siguiente mensaje

‚ö†Ô∏è *Importante:* 
‚Ä¢ Monto exacto: {amount_cup:,.0f} CUP
‚Ä¢ Solo pagos propios
‚Ä¢ Verificaci√≥n: 5-15 minutos"""
        
        # Registrar en base de datos
        log_deposit(deposit_id, user_id, amount_cup, amount_prc, cup_rate, method, "pending")
        
        bot.send_message(
            message.chat.id,
            payment_text,
            parse_mode='Markdown'
        )
        
        bot.send_message(
            message.chat.id,
            "üì∏ *Ahora env√≠a la captura del comprobante de pago:*",
            parse_mode='Markdown'
        )
        
    except Exception as e:
        print(f"‚ùå Error procesando dep√≥sito: {e}")
        bot.send_message(
            message.chat.id,
            "‚ùå Error al procesar el dep√≥sito. Intenta nuevamente.",
            parse_mode='Markdown',
            reply_markup=operations_menu()
        )

# =============================================================================
# SISTEMA DE TIENDA MEJORADO - CON N√öMERO DE TEL√âFONO
# =============================================================================

@bot.message_handler(func=lambda message: message.text in ["üåê Paquetes Internet", "üéÆ Juegos Digitales", "üíª Software", "üì± Otros Productos"])
def show_shop_category(message):
    """Muestra productos por categor√≠a"""
    category = message.text
    category_key = {
        "üåê Paquetes Internet": "internet",
        "üéÆ Juegos Digitales": "gaming", 
        "üíª Software": "software",
        "üì± Otros Productos": "other"
    }
    
    show_products(message, category_key[category])

def show_products(message, category):
    """Muestra productos de una categor√≠a espec√≠fica"""
    conn = sqlite3.connect('cubawallet.db', check_same_thread=False)
    cursor = conn.cursor()
    cursor.execute('SELECT * FROM products WHERE category = ? AND is_available = 1', (category,))
    products = cursor.fetchall()
    conn.close()
    
    category_names = {
        "internet": "üåê Paquetes Internet",
        "gaming": "üéÆ Juegos Digitales", 
        "software": "üíª Software",
        "other": "üì± Otros Productos"
    }
    
    if not products:
        bot.send_message(
            message.chat.id,
            f"üì¶ *{category_names[category]}*\n\n"
            "üòî No hay productos disponibles en esta categor√≠a en este momento.\n\n"
            "Vuelve pronto para nuevas ofertas! üéÅ",
            parse_mode='Markdown',
            reply_markup=shop_menu()
        )
        return
    
    # Crear mensaje con productos
    shop_text = f"üõçÔ∏è *{category_names[category]}* üõçÔ∏è\n\n"
    shop_text += "üì¶ *Productos disponibles:*\n\n"
    
    markup = types.InlineKeyboardMarkup(row_width=2)
    
    for product in products:
        shop_text += f"üîπ *{product[1]}*\n"
        shop_text += f"üìù {product[2]}\n"
        shop_text += f"üí∞ *Precio:* {product[3]:.1f} PRC\n\n"
        
        # Bot√≥n para comprar cada producto
        btn_buy = types.InlineKeyboardButton(
            f"üõí Comprar {product[1].split()[0]}", 
            callback_data=f"buy_{product[0]}"
        )
        markup.add(btn_buy)
    
    shop_text += "üí° *Selecciona un producto para comprar:*"
    
    btn_back = types.InlineKeyboardButton("üîô Volver a Categor√≠as", callback_data="back_to_categories")
    markup.add(btn_back)
    
    bot.send_message(
        message.chat.id,
        shop_text,
        parse_mode='Markdown',
        reply_markup=markup
    )

@bot.callback_query_handler(func=lambda call: call.data.startswith('buy_'))
def handle_buy_product(call):
    """Maneja la compra de productos"""
    try:
        product_id = call.data[4:]  # Remover 'buy_' del callback data
        user_id = call.from_user.id
        user_info = get_user_info(user_id)
        
        # Obtener informaci√≥n del producto
        conn = sqlite3.connect('cubawallet.db', check_same_thread=False)
        cursor = conn.cursor()
        cursor.execute('SELECT * FROM products WHERE product_id = ?', (product_id,))
        product = cursor.fetchone()
        conn.close()
        
        if not product:
            bot.answer_callback_query(call.id, "‚ùå Producto no encontrado")
            return
        
        if user_info[3] < product[3]:
            bot.answer_callback_query(
                call.id, 
                f"‚ùå Saldo insuficiente. Necesitas {product[3]} PRC"
            )
            return
        
        # Si es un paquete de internet, pedir el n√∫mero de tel√©fono
        if product[4] == 'internet':
            # Guardar la compra pendiente
            pending_orders[user_id] = {
                'product_id': product_id,
                'product_name': product[1],
                'price': product[3]
            }
            
            bot.delete_message(chat_id=call.message.chat.id, message_id=call.message.message_id)
            msg = bot.send_message(
                call.message.chat.id,
                f"üì± *COMPRA DE {product[1]}*\n\n"
                "Por favor, ingresa el n√∫mero de tel√©fono para recargar:\n\n"
                "üí° *Formato:* 5XXXXXXXX",
                parse_mode='Markdown'
            )
            bot.register_next_step_handler(msg, process_phone_number)
        else:
            # Para otros productos, procesar directamente
            process_product_purchase(user_id, product, call.message.chat.id)
            
    except Exception as e:
        print(f"‚ùå Error en compra: {e}")
        bot.answer_callback_query(call.id, "‚ùå Error al procesar compra")

def process_phone_number(message):
    """Procesa el n√∫mero de tel√©fono para recarga"""
    try:
        user_id = message.from_user.id
        phone = message.text.strip()
        
        # Validar n√∫mero de tel√©fono (cubano: 5XXXXXXXX)
        if not phone.isdigit() or len(phone) != 9 or not phone.startswith('5'):
            bot.send_message(
                message.chat.id,
                "‚ùå *N√∫mero de tel√©fono inv√°lido.*\n\n"
                "üí° *Aseg√∫rate de:*\n"
                "- Ingresar 9 d√≠gitos\n"
                "- Comenzar con 5\n\n"
                "*Ejemplo:* 512345678",
                parse_mode='Markdown',
                reply_markup=shop_menu()
            )
            return
        
        # Obtener la compra pendiente
        order_data = pending_orders.get(user_id)
        if not order_data:
            bot.send_message(
                message.chat.id,
                "‚ùå *Sesi√≥n expirada.*\n\n"
                "üí° *Vuelve a seleccionar el producto.*",
                parse_mode='Markdown',
                reply_markup=shop_menu()
            )
            return
        
        # Obtener informaci√≥n del producto
        conn = sqlite3.connect('cubawallet.db', check_same_thread=False)
        cursor = conn.cursor()
        cursor.execute('SELECT * FROM products WHERE product_id = ?', (order_data['product_id'],))
        product = cursor.fetchone()
        conn.close()
        
        # Procesar la compra con el tel√©fono
        process_product_purchase(user_id, product, message.chat.id, phone)
        
        # Limpiar compra pendiente
        del pending_orders[user_id]
        
    except Exception as e:
        print(f"‚ùå Error procesando tel√©fono: {e}")
        bot.send_message(message.chat.id, "‚ùå Error al procesar el tel√©fono.")

def process_product_purchase(user_id, product, chat_id, phone=None):
    """Procesa la compra del producto"""
    try:
        user_info = get_user_info(user_id)
        
        # Procesar compra
        update_balance(user_id, -product[3])
        
        # Registrar transacci√≥n
        transaction_id = f"BUY{uuid.uuid4().hex[:8].upper()}"
        log_transaction(transaction_id, user_id, None, product[3], "shop_purchase", "completed")
        
        # Registrar orden
        order_id = f"ORD{uuid.uuid4().hex[:8].upper()}"
        create_order(order_id, user_id, product[0], product[1], 1, product[3], phone)
        
        # Mensaje de confirmaci√≥n
        success_text = f"""
üéâ *¬°COMPRA EXITOSA!* üéâ

üõçÔ∏è *Producto adquirido:*
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚îÇ üì¶ {product[1]}
‚îÇ üí∞ Precio: {product[3]:.1f} PRC
‚îÇ üìã Transacci√≥n: {transaction_id}
‚îÇ üì¶ Orden: {order_id}
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
"""
        if phone:
            success_text += f"üì± *Tel√©fono:* {phone}\n\n"
        
        success_text += f"""
üìä *Detalles de tu compra:*
‚Ä¢ Producto: {product[1]}
‚Ä¢ Precio: {product[3]:.1f} PRC
‚Ä¢ Nuevo saldo: {user_info[3] - product[3]:.2f} PRC
‚Ä¢ Fecha: {datetime.now().strftime('%Y-%m-%d %H:%M')}

üì¶ *Instrucciones de entrega:*
Tu producto ser√° entregado en un plazo m√°ximo de 24 horas. 
Recibir√°s notificaci√≥n cuando est√© disponible.

üíå *Para consultas:* @TuUsuarioDeSoporte"""
        
        bot.send_message(
            chat_id,
            success_text,
            parse_mode='Markdown',
            reply_markup=shop_menu()
        )
        
        # Notificar al grupo
        notification_text = f"üõçÔ∏è *NUEVA COMPRA EN TIENDA*\n\nüë§ Usuario: {escape_markdown(user_info[2])}\nüì¶ Producto: {product[1]}\nüí∞ Precio: {product[3]:.1f} PRC\nüìã Transacci√≥n: {transaction_id}\nüì¶ Orden: {order_id}"
        if phone:
            notification_text += f"\nüì± Tel√©fono: {phone}"
        
        send_group_notification(notification_text)
        
    except Exception as e:
        print(f"‚ùå Error en process_product_purchase: {e}")
        bot.send_message(chat_id, "‚ùå Error al procesar la compra.")

@bot.callback_query_handler(func=lambda call: call.data == "back_to_categories")
def back_to_categories(call):
    """Vuelve a las categor√≠as de la tienda"""
    bot.edit_message_text(
        chat_id=call.message.chat.id,
        message_id=call.message.message_id,
        text="üõçÔ∏è *Selecciona una categor√≠a:*",
        parse_mode='Markdown',
        reply_markup=shop_menu()
    )

# =============================================================================
# SISTEMA DE ENTREGA DE PEDIDOS - NUEVO COMANDO
# =============================================================================

@bot.message_handler(commands=['entrega'])
def deliver_order(message):
    """Marca una orden como entregada y notifica al usuario"""
    try:
        user_id = message.from_user.id
        
        if not is_admin(user_id):
            bot.reply_to(message, "‚ùå *Comando solo para administradores*", parse_mode='Markdown')
            return
        
        parts = message.text.split()
        if len(parts) != 2:
            bot.reply_to(message, 
                        "‚ùå *Formato incorrecto*\n\n"
                        "Uso: `/entrega ORDER_ID`\n\n"
                        "‚Ä¢ ORDER_ID = ID de la orden a marcar como entregada\n\n"
                        "Ejemplo: `/entrega ORDABC123`", 
                        parse_mode='Markdown')
            return
        
        order_id = parts[1]
        
        # Obtener informaci√≥n de la orden
        order_info = get_order_info(order_id)
        if not order_info:
            bot.reply_to(message, f"‚ùå *Orden no encontrada:* `{order_id}`", parse_mode='Markdown')
            return
        
        if order_info[6] == "delivered":
            bot.reply_to(message, f"‚ùå *La orden ya fue entregada*", parse_mode='Markdown')
            return
        
        # Actualizar estado a entregado
        update_order_status(order_id, "delivered")
        
        # Notificar al usuario
        user_notification = f"""
üéâ *¬°TU PEDIDO HA SIDO ENTREGADO!*

‚úÖ *Orden:* {order_id}
üì¶ *Producto:* {order_info[3]}
üí∞ *Precio:* {order_info[5]:.1f} PRC
üìÖ *Fecha de entrega:* {datetime.now().strftime('%Y-%m-%d %H:%M')}

¬°Gracias por tu compra! üéÅ

üíå *¬øProblemas con tu pedido?* Contacta a @TuUsuarioDeSoporte"""
        
        try:
            bot.send_message(order_info[1], user_notification, parse_mode='Markdown')
        except Exception as e:
            print(f"No se pudo notificar al usuario: {e}")
        
        # Notificar al grupo
        send_group_notification(f"‚úÖ *Orden entregada:* `{order_id}`\nüë§ Usuario: {escape_markdown(order_info[9])}\nüì¶ Producto: {order_info[3]}")
        
        bot.reply_to(message, f"‚úÖ *Orden marcada como entregada y notificada al usuario*")
        
    except Exception as e:
        print(f"‚ùå Error en entrega: {e}")
        bot.reply_to(message, "‚ùå Error al procesar la entrega")

# =============================================================================
# MANEJADOR DE FOTOS (PARA DEP√ìSITOS)
# =============================================================================

@bot.message_handler(content_types=['photo'])
def handle_screenshot(message):
    """Manejador de capturas de pantalla para dep√≥sitos"""
    try:
        user_id = message.from_user.id
        
        if user_id not in pending_deposits:
            bot.reply_to(message, "‚ùå No tienes un dep√≥sito pendiente. Usa el men√∫ para iniciar un dep√≥sito.")
            return
        
        user_info = get_user_info(user_id)
        deposit_data = pending_deposits[user_id]
        
        photo_id = message.photo[-1].file_id
        
        # Actualizar base de datos
        conn = sqlite3.connect('cubawallet.db', check_same_thread=False)
        cursor = conn.cursor()
        cursor.execute('UPDATE deposits SET screenshot_id = ? WHERE deposit_id = ?', (photo_id, deposit_data['deposit_id']))
        conn.commit()
        conn.close()
        
        method_display = "Transferm√≥vil" if deposit_data['method'] == "transfermovil" else "EnZona"
        
        # Notificar al grupo
        group_notification = f"""
üì• *NUEVO DEP√ìSITO PENDIENTE* üì•

üë§ *Usuario:* {escape_markdown(user_info[2])}
üíº *Wallet:* `{user_info[4]}`
üì± *M√©todo:* {method_display}
üí∞ *CUP depositados:* {deposit_data['amount_cup']:,.0f} CUP
üíé *ProCoin a recibir:* {deposit_data['amount_prc']:.2f} PRC
üí± *Tasa:* 1 PRC = {deposit_data['exchange_rate']:,.0f} CUP
üìã *Dep√≥sito ID:* `{deposit_data['deposit_id']}`

‚è≥ *Esperando verificaci√≥n...*

‚úÖ *Para aprobar usa:*
`/recargar {user_info[4]} {deposit_data['amount_prc']:.2f}`"""
        
        send_group_notification(group_notification, photo_id=photo_id)
        
        # Confirmar al usuario
        bot.reply_to(message,
                    f"‚úÖ *Captura recibida correctamente*\n\n"
                    f"üìã *Resumen de tu dep√≥sito:*\n"
                    f"‚Ä¢ M√©todo: {method_display}\n"
                    f"‚Ä¢ CUP depositados: {deposit_data['amount_cup']:,.0f} CUP\n"
                    f"‚Ä¢ ProCoin a recibir: {deposit_data['amount_prc']:.2f} PRC\n"
                    f"‚Ä¢ Tasa: 1 PRC = {deposit_data['exchange_rate']:,.0f} CUP\n"
                    f"‚Ä¢ ID: {deposit_data['deposit_id']}\n\n"
                    f"‚è∞ *Estado:* En revisi√≥n\n"
                    f"üìû *Tiempo estimado:* 5-15 minutos\n\n"
                    f"Te notificaremos cuando sea verificado.",
                    parse_mode='Markdown',
                    reply_markup=main_menu())
        
        # Limpiar dep√≥sito pendiente
        del pending_deposits[user_id]
        
    except Exception as e:
        print(f"‚ùå Error manejando screenshot: {e}")
        bot.reply_to(message, "‚ùå Error al procesar la captura. Intenta nuevamente.")

# =============================================================================
# COMANDOS DE ADMINISTRADOR MEJORADOS
# =============================================================================

@bot.message_handler(commands=['recargar'])
def recharge_balance(message):
    """COMANDO RECARGAR PARA ADMINISTRADORES"""
    try:
        user_id = message.from_user.id
        
        if not is_admin(user_id):
            bot.reply_to(message, "‚ùå *Comando solo para administradores*", parse_mode='Markdown')
            return
        
        parts = message.text.split()
        if len(parts) != 3:
            bot.reply_to(message, 
                        "‚ùå *Formato incorrecto*\n\n"
                        "Uso: `/recargar WALLET CANTIDAD`\n\n"
                        "‚Ä¢ WALLET = Direcci√≥n del usuario\n"
                        "‚Ä¢ CANTIDAD = ProCoin a recargar\n\n"
                        "Ejemplo: `/recargar PRCABC123 100\\.50`", 
                        parse_mode='Markdown')
            return
        
        wallet_address = parts[1]
        try:
            amount = float(parts[2])
        except ValueError:
            bot.reply_to(message, "‚ùå *Cantidad inv√°lida*", parse_mode='Markdown')
            return
        
        user_info = get_user_by_wallet(wallet_address)
        if not user_info:
            bot.reply_to(message, f"‚ùå *Wallet no encontrada:* `{wallet_address}`", parse_mode='Markdown')
            return
        
        old_balance = user_info[3]
        update_balance(user_info[0], amount)
        new_balance = old_balance + amount
        
        transaction_id = f"ADM{uuid.uuid4().hex[:8].upper()}"
        log_transaction(transaction_id, None, user_info[0], amount, "admin_recharge", "completed")
        
        # Notificar al usuario
        try:
            user_notification = f"""
üíé *RECARGA DE PROCOIN APROBADA*

‚úÖ Se ha recargado tu cuenta con *{amount:.2f} PRC*

üìä *Detalles:*
‚Ä¢ Wallet: `{wallet_address}`
‚Ä¢ Transacci√≥n: {transaction_id}
‚Ä¢ Saldo anterior: {old_balance:.2f} PRC
‚Ä¢ Nuevo saldo: *{new_balance:.2f} PRC*

¬°Gracias por usar ProCoin\\! üéâ"""
            
            bot.send_message(user_info[0], user_notification, parse_mode='Markdown')
        except Exception as e:
            print(f"No se pudo notificar al usuario: {e}")
        
        # Notificar al grupo
        group_notification = f"""
üíé *RECARGA MANUAL DE PROCOIN* üíé

*Administrador:* {escape_markdown(message.from_user.first_name)}
*Usuario:* {escape_markdown(user_info[2])}
*Wallet:* `{wallet_address}`
*ProCoin:* {amount:.2f} PRC
*Transacci√≥n:* `{transaction_id}`
*Nuevo saldo:* {new_balance:.2f} PRC

‚úÖ *Recarga completada exitosamente*"""
        
        send_group_notification(group_notification)
        
        bot.reply_to(message, 
                    f"‚úÖ *Recarga exitosa*\n\n"
                    f"üë§ Usuario: {escape_markdown(user_info[2])}\n"
                    f"üíé ProCoin: {amount:.2f} PRC\n"
                    f"üí∞ Nuevo saldo: {new_balance:.2f} PRC",
                    parse_mode='Markdown')
                    
    except Exception as e:
        print(f"‚ùå Error en recargar: {e}")
        bot.reply_to(message, "‚ùå Error al procesar la recarga")

@bot.message_handler(commands=['aprobar_retiro'])
def approve_withdrawal(message):
    """Aprueba un retiro pendiente"""
    try:
        user_id = message.from_user.id
        
        if not is_admin(user_id):
            bot.reply_to(message, "‚ùå *Comando solo para administradores*", parse_mode='Markdown')
            return
        
        parts = message.text.split()
        if len(parts) != 2:
            bot.reply_to(message, 
                        "‚ùå *Formato incorrecto*\n\n"
                        "Uso: `/aprobar_retiro RETIRO_ID`\n\n"
                        "‚Ä¢ RETIRO_ID = ID del retiro pendiente\n\n"
                        "Ejemplo: `/aprobar_retiro WDABC123`", 
                        parse_mode='Markdown')
            return
        
        withdrawal_id = parts[1]
        
        # Obtener informaci√≥n del retiro
        conn = sqlite3.connect('cubawallet.db', check_same_thread=False)
        cursor = conn.cursor()
        cursor.execute('SELECT * FROM withdrawals WHERE withdrawal_id = ?', (withdrawal_id,))
        withdrawal = cursor.fetchone()
        
        if not withdrawal:
            bot.reply_to(message, f"‚ùå *Retiro no encontrado:* `{withdrawal_id}`", parse_mode='Markdown')
            conn.close()
            return
        
        if withdrawal[9] != "pending":
            bot.reply_to(message, f"‚ùå *El retiro ya fue procesado*", parse_mode='Markdown')
            conn.close()
            return
        
        # Actualizar estado a completado
        cursor.execute('UPDATE withdrawals SET status = ? WHERE withdrawal_id = ?', ("completed", withdrawal_id))
        conn.commit()
        conn.close()
        
        # Notificar al usuario
        user_notification = f"""
‚úÖ *RETIRO APROBADO*

Tu solicitud de retiro ha sido aprobada y procesada.

üìã *Detalles:*
‚Ä¢ ID: {withdrawal_id}
‚Ä¢ ProCoin retirados: {withdrawal[2]:.2f} PRC
‚Ä¢ Monto recibido: {withdrawal[6]:,.0f} CUP
‚Ä¢ Tarjeta: {withdrawal[7][-4:]}
‚Ä¢ Fecha: {datetime.now().strftime('%Y-%m-%d %H:%M')}

¬°Gracias por usar ProCoin! üéâ"""
        
        try:
            bot.send_message(withdrawal[1], user_notification, parse_mode='Markdown')
        except Exception as e:
            print(f"No se pudo notificar al usuario: {e}")
        
        # Notificar al grupo
        send_group_notification(f"‚úÖ *Retiro aprobado:* `{withdrawal_id}`")
        
        bot.reply_to(message, f"‚úÖ *Retiro aprobado exitosamente*")
        
    except Exception as e:
        print(f"‚ùå Error aprobando retiro: {e}")
        bot.reply_to(message, "‚ùå Error al aprobar el retiro")

@bot.message_handler(commands=['debug_tasas'])
def debug_tasas_command(message):
    """Debug del sistema de tasas"""
    user_id = message.from_user.id
    
    if not is_admin(user_id):
        bot.reply_to(message, "‚ùå *Comando solo para administradores*", parse_mode='Markdown')
        return
    
    try:
        # Forzar actualizaci√≥n
        all_rates = get_eltoque_rates_cached()
        
        debug_text = f"""
üîß *DEBUG TASAS - ACTUALIZACI√ìN 1 MINUTO*

üí∞ *Tasas en cach√©:*
{all_rates}

üíµ *Tasa USD:* {get_cup_usd_rate()}
üí∂ *Tasa EUR:* {get_cup_eur_rate()}

‚è∞ *Cache actualizado:* {datetime.fromtimestamp(last_api_call).strftime('%H:%M:%S') if last_api_call > 0 else 'Nunca'}
‚è±Ô∏è *Edad del cach√©:* {time.time() - last_api_call:.1f}s
üîÑ *Actualizaci√≥n cada:* {CACHE_DURATION}s"""
        
        bot.reply_to(message, debug_text, parse_mode='Markdown')
    except Exception as e:
        bot.reply_to(message, f"‚ùå Error en debug: {e}")

# =============================================================================
# INICIALIZACI√ìN MEJORADA
# =============================================================================

def run_bot():
    """Funci√≥n principal mejorada"""
    print("üöÄ Iniciando Bot ProCoin SUPER MEJORADO...")
    
    try:
        # Inicializar base de datos
        init_db()
        
        # Probar sistema de tasas
        print("üß™ Probando sistema de tasas...")
        initial_rates = get_eltoque_rates_cached()
        
        if initial_rates:
            print(f"‚úÖ Sistema de tasas funcionando - {len(initial_rates)} tasas cargadas")
            send_group_notification(f"ü§ñ *Bot ProCoin SUPER MEJORADO Iniciado*\n‚úÖ Sistema de tasas activo\nüí∞ {len(initial_rates)} tasas cargadas\nüõçÔ∏è Tienda integrada\n‚è∞ Cache: 1 minuto")
        else:
            print("‚ö†Ô∏è Sistema de tasas con valores por defecto")
            send_group_notification("ü§ñ *Bot ProCoin SUPER MEJORADO Iniciado*\n‚ö†Ô∏è Sistema de tasas con valores por defecto\nüõçÔ∏è Tienda integrada\n‚è∞ Cache: 1 minuto")
        
        print("üîÑ Iniciando polling del bot...")
        bot.polling(none_stop=True, interval=1, timeout=60)
        
    except Exception as e:
        print(f"‚ùå Error cr√≠tico: {e}")
        send_group_notification(f"üö® *Error cr√≠tico en el bot:* {escape_markdown(str(e))}")
        time.sleep(10)
        run_bot()  # Reiniciar

if __name__ == "__main__":
    # Ejecutar el bot en un hilo separado
    bot_thread = threading.Thread(target=run_bot, daemon=True)
    bot_thread.start()
    
    # Mantener el programa principal ejecut√°ndose
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        print("\nüëã Deteniendo bot...")
        send_group_notification("üõë *Bot detenido manualmente*")
