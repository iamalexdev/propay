import telebot
from telebot import types
import sqlite3
import uuid
from datetime import datetime
import html
import re
import time
import os
import requests
import json
from bs4 import BeautifulSoup
import threading
import traceback

# Configuraci√≥n
TOKEN = "8400947960:AAGGXHezQbmUqk6AOpgT1GqMLaF-rMvVp9Y"
GROUP_CHAT_ID = "-4932107704"
ADMIN_ID = 1853800972
bot = telebot.TeleBot(TOKEN)

# Configuraci√≥n de la API ElToque
ELTOQUE_API_URL = "https://tasas.eltoque.com/v1/trmi"
ELTOQUE_API_TOKEN = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmcmVzaCI6ZmFsc2UsImlhdCI6MTc2MTE0NzQzMSwianRpIjoiMTc4ZGIyZWYtNWIzNy00MzJhLTkwYTktNTczZDBiOGE2N2ViIiwidHlwZSI6ImFjY2VzcyIsInN1YiI6IjY4ZjgyZjM1ZTkyYmU3N2VhMzAzODJhZiIsIm5iZiI6MTc2MTE0NzQzMSwiZXhwIjoxNzkyNjgzNDMxfQ.gTIXoSudOyo99vLLBap74_5UfdSRdOLluXekb0F1cPg"

# =============================================================================
# SISTEMA DE CACH√â PARA TASAS
# =============================================================================

# Variables globales para el cach√©
rates_cache = None
last_api_call = 0
CACHE_DURATION = 2  # segundos (m√°s de 1 para seguridad)

def get_eltoque_rates_cached():
    """
    Obtiene las tasas de cambio con cach√© para evitar m√∫ltiples peticiones
    """
    global rates_cache, last_api_call
    
    current_time = time.time()
    
    # Si tenemos datos en cach√© y no han pasado m√°s de CACHE_DURATION segundos, usamos el cach√©
    if rates_cache is not None and (current_time - last_api_call) < CACHE_DURATION:
        print("‚úÖ Usando tasas en cach√©")
        send_group_notification("üîÑ *Sistema Tasas:* Usando tasas en cach√©")
        return rates_cache
    
    print("üîÑ Haciendo nueva petici√≥n a la API...")
    send_group_notification("üîÑ *Sistema Tasas:* Haciendo nueva petici√≥n a API ElToque...")
    
    # Si no, hacemos la petici√≥n a la API
    new_rates = get_eltoque_rates()
    
    # Solo actualizar el cach√© si obtuvimos datos
    if new_rates is not None:
        rates_cache = new_rates
        last_api_call = current_time
        print(f"‚úÖ Cach√© actualizado con {len(new_rates)} tasas")
        send_group_notification(f"‚úÖ *Sistema Tasas:* Cach√© actualizado con {len(new_rates)} tasas")
    else:
        print("‚ö†Ô∏è No se pudieron obtener nuevas tasas, manteniendo cach√© anterior")
        send_group_notification("‚ö†Ô∏è *Sistema Tasas:* No se pudieron obtener nuevas tasas, usando cach√© anterior")
    
    return rates_cache

# =============================================================================
# FUNCIONES DE API ELTOQUE
# =============================================================================

def get_eltoque_rates():
    """
    Obtiene las tasas de cambio desde la API oficial de ElToque
    Retorna: dict con las tasas o None si hay error
    """
    try:
        # Formatear fechas para hoy
        today = datetime.now().strftime("%Y-%m-%d")
        date_from = f"{today} 00:00:01"
        date_to = f"{today} 23:59:01"
        
        # Par√°metros de la consulta
        params = {
            'date_from': date_from,
            'date_to': date_to
        }
        
        headers = {
            'accept': '*/*',
            'Authorization': f'Bearer {ELTOQUE_API_TOKEN}',
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        }
        
        print(f"üîó Solicitando: {ELTOQUE_API_URL}")
        print(f"üìÖ Con par√°metros: {params}")
        
        response = requests.get(ELTOQUE_API_URL, params=params, headers=headers, timeout=15)
        
        print(f"üì° Status Code: {response.status_code}")
        
        if response.status_code != 200:
            error_msg = f"‚ùå Error HTTP {response.status_code}: {response.text}"
            print(error_msg)
            send_group_notification(f"‚ùå *Error API:* {error_msg}")
            return None
            
        data = response.json()
        print(f"‚úÖ Respuesta recibida, tipo: {type(data)}")
        
        # Procesar la estructura real de la respuesta
        rates = {}
        
        if isinstance(data, dict) and 'tasas' in data:
            # Extraer las tasas del campo 'tasas'
            tasas_data = data['tasas']
            print(f"üìä Campo 'tasas' encontrado: {tasas_data}")
            
            for currency, rate in tasas_data.items():
                try:
                    rates[currency] = float(rate)
                    print(f"  ‚úÖ {currency}: {rate}")
                except (ValueError, TypeError) as e:
                    print(f"  ‚ùå Error convirtiendo {currency}: {rate} - {e}")
        
        # Mostrar informaci√≥n de fecha/hora
        if 'date' in data:
            print(f"üìÖ Fecha: {data['date']}")
        if 'hour' in data:
            print(f"üïí Hora: {data['hour']}:{data.get('minutes', '00')}:{data.get('seconds', '00')}")
        
        print(f"üí∞ Total tasas procesadas: {len(rates)}")
        
        if not rates:
            error_msg = "‚ùå No se pudieron extraer tasas de la respuesta"
            print(error_msg)
            send_group_notification(f"‚ùå *Error API:* {error_msg}")
            return None
            
        # Enviar resumen de tasas al grupo
        tasas_resumen = ", ".join([f"{k}: {v}" for k, v in rates.items()])
        send_group_notification(f"üìà *Tasas obtenidas:* {tasas_resumen}")
            
        return rates
        
    except requests.exceptions.Timeout:
        error_msg = "‚ùå Timeout conectando a API ElToque"
        print(error_msg)
        send_group_notification(f"‚ùå *Error API:* {error_msg}")
        return None
    except requests.exceptions.ConnectionError:
        error_msg = "‚ùå Error de conexi√≥n con API ElToque"
        print(error_msg)
        send_group_notification(f"‚ùå *Error API:* {error_msg}")
        return None
    except requests.exceptions.RequestException as e:
        error_msg = f"‚ùå Error en solicitud a API ElToque: {e}"
        print(error_msg)
        send_group_notification(f"‚ùå *Error API:* {error_msg}")
        return None
    except ValueError as e:
        error_msg = f"‚ùå Error parseando JSON de API ElToque: {e}"
        print(error_msg)
        send_group_notification(f"‚ùå *Error API:* {error_msg}")
        return None
    except Exception as e:
        error_msg = f"‚ùå Error inesperado en API ElToque: {e}"
        print(error_msg)
        traceback.print_exc()
        send_group_notification(f"‚ùå *Error API:* {error_msg}")
        return None

def get_cup_usd_rate():
    """
    Obtiene la tasa de cambio CUP/USD desde el cach√©
    Retorna: float o valor por defecto si hay error
    """
    try:
        rates = get_eltoque_rates_cached()
        
        if rates:
            # Buscar USD en las tasas disponibles
            if 'USD' in rates:
                cup_usd_rate = rates['USD']
                print(f"‚úÖ Tasa CUP/USD obtenida: {cup_usd_rate}")
                return cup_usd_rate
            elif 'USDT_TRC20' in rates:
                cup_usd_rate = rates['USDT_TRC20']
                print(f"‚úÖ Tasa CUP/USDT obtenida: {cup_usd_rate}")
                return cup_usd_rate
        
        # Fallback si no se encuentra USD
        error_msg = "‚ö†Ô∏è No se encontr√≥ tasa USD, usando valor por defecto: 490.0"
        print(error_msg)
        send_group_notification(f"‚ö†Ô∏è *Sistema Tasas:* {error_msg}")
        return 490.0
        
    except Exception as e:
        error_msg = f"‚ùå Error obteniendo tasa CUP/USD: {e}"
        print(error_msg)
        send_group_notification(f"‚ùå *Error Tasas:* {error_msg}")
        return 490.0

def get_cup_eur_rate():
    """
    Obtiene la tasa de cambio CUP/EUR desde el cach√©
    Retorna: float o valor por defecto si hay error
    """
    try:
        rates = get_eltoque_rates_cached()
        
        if rates:
            # Buscar EUR/ECU en las tasas disponibles
            if 'ECU' in rates:
                cup_eur_rate = rates['ECU']
                print(f"‚úÖ Tasa CUP/EUR (ECU) obtenida: {cup_eur_rate}")
                return cup_eur_rate
        
        # Fallback si no se encuentra EUR
        error_msg = "‚ö†Ô∏è No se encontr√≥ tasa EUR, usando valor por defecto: 540.0"
        print(error_msg)
        send_group_notification(f"‚ö†Ô∏è *Sistema Tasas:* {error_msg}")
        return 540.0
        
    except Exception as e:
        error_msg = f"‚ùå Error obteniendo tasa CUP/EUR: {e}"
        print(error_msg)
        send_group_notification(f"‚ùå *Error Tasas:* {error_msg}")
        return 540.0

# =============================================================================
# FUNCIONES PRINCIPALES
# =============================================================================

# Diccionarios para operaciones pendientes
pending_deposits = {}
pending_withdrawals = {}

# Funci√≥n para enviar notificaciones al grupo
def send_group_notification(message, photo_id=None):
    try:
        if photo_id:
            bot.send_photo(
                chat_id=GROUP_CHAT_ID,
                photo=photo_id,
                caption=message,
                parse_mode='Markdown'
            )
        else:
            bot.send_message(
                chat_id=GROUP_CHAT_ID,
                text=message,
                parse_mode='Markdown'
            )
        print(f"‚úÖ Notificaci√≥n enviada al grupo {GROUP_CHAT_ID}")
        return True
    except Exception as e:
        print(f"‚ùå Error enviando notificaci√≥n: {e}")
        return False

# Inicializar Base de Datos
def init_db():
    conn = sqlite3.connect('cubawallet.db')
    cursor = conn.cursor()
    
    # Tabla de usuarios
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS users (
            user_id INTEGER PRIMARY KEY,
            username TEXT,
            first_name TEXT,
            balance REAL DEFAULT 0.0,
            wallet_address TEXT UNIQUE,
            registered_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
    ''')
    
    # Tabla de transacciones
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS transactions (
            transaction_id TEXT PRIMARY KEY,
            from_user INTEGER,
            to_user INTEGER,
            amount REAL,
            currency TEXT DEFAULT 'PRC',
            transaction_type TEXT,
            status TEXT,
            timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (from_user) REFERENCES users (user_id),
            FOREIGN KEY (to_user) REFERENCES users (user_id)
        )
    ''')
    
    # Tabla de dep√≥sitos
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS deposits (
            deposit_id TEXT PRIMARY KEY,
            user_id INTEGER,
            amount_cup REAL,
            amount_prc REAL,
            exchange_rate REAL,
            method TEXT,
            status TEXT,
            screenshot_id TEXT,
            admin_approved INTEGER,
            timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (user_id) REFERENCES users (user_id)
        )
    ''')
    
    # Tabla de retiros
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS withdrawals (
            withdrawal_id TEXT PRIMARY KEY,
            user_id INTEGER,
            amount_prc REAL,
            amount_cup REAL,
            exchange_rate REAL,
            fee REAL,
            net_amount REAL,
            card_number TEXT,
            status TEXT,
            screenshot_id TEXT,
            admin_approved INTEGER,
            timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (user_id) REFERENCES users (user_id)
        )
    ''')
    
    conn.commit()
    conn.close()

# Funci√≥n para limpiar la base de datos (solo admin)
def clear_database():
    try:
        conn = sqlite3.connect('cubawallet.db')
        cursor = conn.cursor()
        
        cursor.execute('DROP TABLE IF EXISTS withdrawals')
        cursor.execute('DROP TABLE IF EXISTS deposits')
        cursor.execute('DROP TABLE IF EXISTS transactions')
        cursor.execute('DROP TABLE IF EXISTS users')
        
        conn.commit()
        conn.close()
        
        init_db()
        return True
    except Exception as e:
        print(f"Error limpiando base de datos: {e}")
        send_group_notification(f"‚ùå *Error BD:* Error limpiando base de datos: {e}")
        return False

# Funci√≥n para escapar texto para Markdown
def escape_markdown(text):
    if text is None:
        return ""
    escape_chars = ['_', '*', '[', ']', '(', ')', '~', '`', '>', '#', '+', '-', '=', '|', '{', '}', '.', '!']
    for char in escape_chars:
        text = str(text).replace(char, f'\\{char}')
    return text

# Funci√≥n para verificar si es administrador
def is_admin(user_id):
    return user_id == ADMIN_ID

# Generar direcci√≥n √∫nica de wallet
def generate_wallet_address():
    return f"PRC{uuid.uuid4().hex[:12].upper()}"

# Registrar usuario en la base de datos
def register_user(user_id, username, first_name):
    conn = sqlite3.connect('cubawallet.db')
    cursor = conn.cursor()
    
    cursor.execute('SELECT * FROM users WHERE user_id = ?', (user_id,))
    user = cursor.fetchone()
    
    if not user:
        wallet_address = generate_wallet_address()
        cursor.execute('''
            INSERT INTO users (user_id, username, first_name, wallet_address, balance)
            VALUES (?, ?, ?, ?, ?)
        ''', (user_id, username, first_name, wallet_address, 0.0))
        conn.commit()
        
        notification_text = f"""
üÜï *NUEVO USUARIO REGISTRADO* üÜï

*Informaci√≥n del usuario:*
‚Ä¢ *Nombre:* {escape_markdown(first_name)}
‚Ä¢ *Username:* @{escape_markdown(username) if username else 'N/A'}
‚Ä¢ *User ID:* `{user_id}`
‚Ä¢ *Wallet:* `{wallet_address}`

*¬°Bienvenido a la familia ProCoin\\!*"""
        
        send_group_notification(notification_text)
    
    conn.close()

# Obtener informaci√≥n del usuario
def get_user_info(user_id):
    conn = sqlite3.connect('cubawallet.db')
    cursor = conn.cursor()
    cursor.execute('SELECT * FROM users WHERE user_id = ?', (user_id,))
    user = cursor.fetchone()
    conn.close()
    return user

# Obtener usuario por wallet address
def get_user_by_wallet(wallet_address):
    conn = sqlite3.connect('cubawallet.db')
    cursor = conn.cursor()
    cursor.execute('SELECT * FROM users WHERE wallet_address = ?', (wallet_address,))
    user = cursor.fetchone()
    conn.close()
    return user

# Actualizar balance ProCoin
def update_balance(user_id, amount):
    conn = sqlite3.connect('cubawallet.db')
    cursor = conn.cursor()
    cursor.execute('UPDATE users SET balance = balance + ? WHERE user_id = ?', (amount, user_id))
    conn.commit()
    conn.close()

# Registrar transacci√≥n ProCoin
def log_transaction(transaction_id, from_user, to_user, amount, transaction_type, status):
    conn = sqlite3.connect('cubawallet.db')
    cursor = conn.cursor()
    cursor.execute('''
        INSERT INTO transactions (transaction_id, from_user, to_user, amount, transaction_type, status)
        VALUES (?, ?, ?, ?, ?, ?)
    ''', (transaction_id, from_user, to_user, amount, transaction_type, status))
    conn.commit()
    conn.close()

# Registrar dep√≥sito CUP
def log_deposit(deposit_id, user_id, amount_cup, amount_prc, exchange_rate, method, status, screenshot_id=None):
    conn = sqlite3.connect('cubawallet.db')
    cursor = conn.cursor()
    cursor.execute('''
        INSERT INTO deposits (deposit_id, user_id, amount_cup, amount_prc, exchange_rate, method, status, screenshot_id)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    ''', (deposit_id, user_id, amount_cup, amount_prc, exchange_rate, method, status, screenshot_id))
    conn.commit()
    conn.close()

# Registrar retiro
def log_withdrawal(withdrawal_id, user_id, amount_prc, amount_cup, exchange_rate, fee, net_amount, card_number, status, screenshot_id=None):
    conn = sqlite3.connect('cubawallet.db')
    cursor = conn.cursor()
    cursor.execute('''
        INSERT INTO withdrawals (withdrawal_id, user_id, amount_prc, amount_cup, exchange_rate, fee, net_amount, card_number, status, screenshot_id)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    ''', (withdrawal_id, user_id, amount_prc, amount_cup, exchange_rate, fee, net_amount, card_number, status, screenshot_id))
    conn.commit()
    conn.close()

# Men√∫ principal con botones inline
def main_menu(chat_id):
    markup = types.InlineKeyboardMarkup(row_width=2)
    
    btn_send = types.InlineKeyboardButton("üì§ Enviar ProCoin", callback_data="send_money")
    btn_receive = types.InlineKeyboardButton("üì• Recibir ProCoin", callback_data="receive_money")
    btn_deposit = types.InlineKeyboardButton("üíµ Depositar CUP", callback_data="deposit_cup")
    btn_withdraw = types.InlineKeyboardButton("üí∏ Retirar CUP", callback_data="withdraw_cup")
    btn_balance = types.InlineKeyboardButton("üí∞ Ver Saldo", callback_data="check_balance")
    btn_rates = types.InlineKeyboardButton("üìà Ver Tasas", callback_data="check_rates")
    
    markup.add(btn_send, btn_receive, btn_deposit, btn_withdraw, btn_balance, btn_rates)
    
    return markup

# =============================================================================
# COMANDOS DE ADMINISTRADOR
# =============================================================================

@bot.message_handler(commands=['limpiar'])
def clear_database_command(message):
    user_id = message.from_user.id
    
    if not is_admin(user_id):
        bot.reply_to(message, "‚ùå *Comando solo para administradores*", parse_mode='Markdown')
        return
    
    markup = types.InlineKeyboardMarkup()
    btn_confirm = types.InlineKeyboardButton("‚úÖ S√≠, limpiar todo", callback_data="confirm_clear")
    btn_cancel = types.InlineKeyboardButton("‚ùå Cancelar", callback_data="cancel_clear")
    markup.add(btn_confirm, btn_cancel)
    
    bot.reply_to(message,
                "‚ö†Ô∏è *¬øEST√ÅS SEGURO DE QUE QUIERES LIMPIAR LA BASE DE DATOS?*\n\n"
                "üö® *ESTA ACCI√ìN ELIMINAR√Å:*\n"
                "‚Ä¢ Todos los usuarios registrados\n"
                "‚Ä¢ Todas las transacciones\n" 
                "‚Ä¢ Todos los dep√≥sitos y retiros\n\n"
                "üî¥ *¬°ESTA ACCI√ìN NO SE PUEDE DESHACER!*",
                parse_mode='Markdown',
                reply_markup=markup)

@bot.message_handler(commands=['recargar'])
def recharge_balance(message):
    user_id = message.from_user.id
    
    if not is_admin(user_id):
        bot.reply_to(message, "‚ùå *Comando solo para administradores*", parse_mode='Markdown')
        return
    
    parts = message.text.split()
    if len(parts) != 3:
        bot.reply_to(message, 
                    "‚ùå *Formato incorrecto*\n\n"
                    "Uso: `/recargar PRCABC123 100.50`\n\n"
                    "‚Ä¢ PRCABC123 = Wallet del usuario\n"
                    "‚Ä¢ 100.50 = Cantidad de ProCoin a recargar", 
                    parse_mode='Markdown')
        return
    
    wallet_address = parts[1]
    try:
        amount = float(parts[2])
    except ValueError:
        bot.reply_to(message, "‚ùå *Cantidad inv√°lida*", parse_mode='Markdown')
        return
    
    user_info = get_user_by_wallet(wallet_address)
    if not user_info:
        bot.reply_to(message, f"‚ùå *Wallet no encontrada:* `{wallet_address}`", parse_mode='Markdown')
        return
    
    old_balance = user_info[3]
    update_balance(user_info[0], amount)
    new_balance = old_balance + amount
    
    transaction_id = f"ADM{uuid.uuid4().hex[:10].upper()}"
    log_transaction(transaction_id, None, user_info[0], amount, "admin_recharge", "completed")
    
    try:
        user_notification = f"""
üíé *RECARGA DE PROCOIN APROBADA*

‚úÖ Se ha recargado tu cuenta con ProCoin.

üìä *Detalles:*
‚Ä¢ ProCoin recargados: {amount:.2f} PRC
‚Ä¢ Wallet: `{wallet_address}`
‚Ä¢ Transacci√≥n: {transaction_id}
‚Ä¢ Saldo anterior: {old_balance:.2f} PRC
‚Ä¢ Nuevo saldo: *{new_balance:.2f} PRC*

¬°Gracias por usar ProCoin! üéâ"""
        
        bot.send_message(user_info[0], user_notification, parse_mode='Markdown')
    except Exception as e:
        print(f"No se pudo notificar al usuario: {e}")
    
    group_notification = f"""
üíé *RECARGA MANUAL DE PROCOIN* üíé

*Administrador:* {escape_markdown(message.from_user.first_name)}
*Usuario:* {escape_markdown(user_info[2])}
*Wallet:* `{wallet_address}`
*ProCoin:* {amount:.2f} PRC
*Transacci√≥n:* `{transaction_id}`
*Nuevo saldo:* {new_balance:.2f} PRC

‚úÖ *Recarga completada exitosamente*"""
    
    send_group_notification(group_notification)
    
    bot.reply_to(message, 
                f"‚úÖ *Recarga exitosa*\n\n"
                f"Usuario: {escape_markdown(user_info[2])}\n"
                f"ProCoin: {amount:.2f} PRC\n"
                f"Nuevo saldo: {new_balance:.2f} PRC",
                parse_mode='Markdown')

@bot.message_handler(commands=['tasas'])
def show_rates_command(message):
    """Comando para ver tasas actuales"""
    show_current_rates(message)

@bot.message_handler(commands=['estadisticas'])
def show_stats(message):
    user_id = message.from_user.id
    
    if not is_admin(user_id):
        bot.reply_to(message, "‚ùå *Comando solo para administradores*", parse_mode='Markdown')
        return
        
    conn = sqlite3.connect('cubawallet.db')
    cursor = conn.cursor()
    
    # Total de usuarios
    cursor.execute('SELECT COUNT(*) FROM users')
    total_users = cursor.fetchone()[0]
    
    # Total de transacciones
    cursor.execute('SELECT COUNT(*) FROM transactions')
    total_transactions = cursor.fetchone()[0]
    
    # Volumen total en ProCoin
    cursor.execute('SELECT SUM(amount) FROM transactions WHERE status = "completed"')
    total_volume_prc = cursor.fetchone()[0] or 0
    
    # Dep√≥sitos pendientes
    cursor.execute('SELECT COUNT(*) FROM deposits WHERE status = "pending"')
    pending_deposits_count = cursor.fetchone()[0]
    
    # Retiros pendientes
    cursor.execute('SELECT COUNT(*) FROM withdrawals WHERE status = "pending"')
    pending_withdrawals_count = cursor.fetchone()[0]
    
    conn.close()
    
    # Obtener tasas actuales
    cup_rate = get_cup_usd_rate()
    
    stats_text = f"""
üìà *ESTAD√çSTICAS DE PROCOIN*

üë• *Usuarios registrados:* {total_users}
üîÑ *Transacciones ProCoin:* {total_transactions}
üíé *Volumen ProCoin:* {total_volume_prc:.2f} PRC
üí∞ *Volumen equivalente CUP:* {total_volume_prc * cup_rate:,.0f} CUP

‚è≥ *Dep√≥sitos pendientes:* {pending_deposits_count}
‚è≥ *Retiros pendientes:* {pending_withdrawals_count}
üìÖ *Actualizado:* {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"""
    
    bot.send_message(
        message.chat.id,
        stats_text,
        parse_mode='Markdown'
    )

@bot.message_handler(commands=['debug_tasas'])
def debug_tasas_command(message):
    """Comando para debuggear las tasas"""
    user_id = message.from_user.id
    
    if not is_admin(user_id):
        bot.reply_to(message, "‚ùå *Comando solo para administradores*", parse_mode='Markdown')
        return
        
    # Testear API
    bot.reply_to(message, "üß™ Probando API ElToque...")
    api_works = test_eltoque_api()
    
    # Testear cach√©
    bot.reply_to(message, "üß™ Probando sistema de cach√©...")
    cache_works = test_cache_system()
    
    # Obtener tasas actuales
    bot.reply_to(message, "üß™ Obteniendo tasas actuales...")
    all_rates = get_eltoque_rates_cached()
    
    debug_text = f"""
üîß *DEBUG TASAS*

üì° *Estado API:* {'‚úÖ Funciona' if api_works else '‚ùå Fall√≥'}
üíæ *Estado Cach√©:* {'‚úÖ Funciona' if cache_works else '‚ùå Fall√≥'}
üí∞ *Tasas obtenidas:* {len(all_rates) if all_rates else 0}

üìä *Contenido de tasas:*
{all_rates}

üíµ *Tasa USD:* {get_cup_usd_rate()}
üí∂ *Tasa EUR:* {get_cup_eur_rate()}
"""
    
    bot.reply_to(message, debug_text, parse_mode='Markdown')

# =============================================================================
# COMANDO START
# =============================================================================

@bot.message_handler(commands=['start'])
def send_welcome(message):
    user_id = message.from_user.id
    username = message.from_user.username
    first_name = message.from_user.first_name
    
    register_user(user_id, username, first_name)
    user_info = get_user_info(user_id)
    
    # Obtener tasas actuales
    cup_rate = get_cup_usd_rate()
    
    welcome_text = f"""
üëã ¬°Bienvenido a ProCoin, {escape_markdown(first_name)}!

üíé *Tu Billetera Digital con ProCoin*

üìä *Informaci√≥n de tu cuenta:*
‚Ä¢ Usuario: {escape_markdown(first_name)}
‚Ä¢ Wallet: `{user_info[4]}`
‚ö° *Selecciona una opci√≥n:*"""
    
    bot.send_message(
        chat_id=message.chat.id,
        text=welcome_text,
        parse_mode='Markdown',
        reply_markup=main_menu(message.chat.id)
    )

# =============================================================================
# MANEJADOR DE CALLBACKS
# =============================================================================

@bot.callback_query_handler(func=lambda call: True)
def handle_callback(call):
    user_id = call.from_user.id
    user_info = get_user_info(user_id)
    
    if call.data == "send_money":
        msg = bot.send_message(
            call.message.chat.id,
            "üíé *ENVIAR PROCOIN*\n\nüìß Ingresa la direcci√≥n de wallet del destinatario:",
            parse_mode='Markdown'
        )
        bot.register_next_step_handler(msg, process_recipient)
    
    elif call.data == "receive_money":
        receive_text = f"""
üì• *RECIBIR PROCOIN*

üÜî *Tu Direcci√≥n de Wallet:*
`{user_info[4]}`

üìã *Instrucciones:*
1. Comparte esta direcci√≥n con quien te enviar√° ProCoin
2. El remitente debe usar la opci√≥n *\"Enviar ProCoin\"*
3. Ingresa tu direcci√≥n √∫nica mostrada arriba
4. ¬°Recibir√°s los ProCoin instant√°neamente!

üí° *Consejo:* Copia tu direcci√≥n haciendo clic en ella."""
        
        bot.edit_message_text(
            chat_id=call.message.chat.id,
            message_id=call.message.message_id,
            text=receive_text,
            parse_mode='Markdown',
            reply_markup=main_menu(call.message.chat.id)
        )
    
    elif call.data == "deposit_cup":
        # Obtener tasa actual
        cup_rate = get_cup_usd_rate()
        
        deposit_text = f"""
üíµ *DEPOSITAR CUP*

Actualmente 1 PRC = *{cup_rate:,.0f} CUP*

üí° *¬øC√≥mo funciona?*
1. Depositas CUP via Transferm√≥vil/EnZona
2. Se convierte autom√°ticamente a ProCoin
3. Recibes ProCoin en tu wallet al tipo de cambio actual

üìä *Ejemplo:*
‚Ä¢ Si depositas {cup_rate:,.0f} CUP
‚Ä¢ Recibir√°s 1.00 PRC

üíé *Selecciona el m√©todo de pago:*"""
        
        deposit_methods = types.InlineKeyboardMarkup(row_width=2)
        btn_transfermovil = types.InlineKeyboardButton("üì± Transferm√≥vil", callback_data="deposit_transfermovil")
        btn_enzona = types.InlineKeyboardButton("üîµ EnZona", callback_data="deposit_enzona")
        btn_back = types.InlineKeyboardButton("üîô Volver", callback_data="back_to_main")
        deposit_methods.add(btn_transfermovil, btn_enzona, btn_back)
        
        bot.edit_message_text(
            chat_id=call.message.chat.id,
            message_id=call.message.message_id,
            text=deposit_text,
            parse_mode='Markdown',
            reply_markup=deposit_methods
        )
    
    elif call.data == "withdraw_cup":
        start_cup_withdrawal(call)
    
    elif call.data == "check_balance":
        show_complete_balance(call)
    
    elif call.data == "check_rates":
        show_current_rates(call)
    
    elif call.data == "deposit_transfermovil":
        start_cup_deposit(call, "transfermovil")
    
    elif call.data == "deposit_enzona":
        start_cup_deposit(call, "enzona")
    
    elif call.data == "back_to_main":
        user_info = get_user_info(user_id)
        cup_rate = get_cup_usd_rate()
        
        welcome_back_text = f"""
üëã ¬°Hola de nuevo, {escape_markdown(user_info[2])}!

üíé *Tu Billetera ProCoin*

üìä *Informaci√≥n actual:*
‚Ä¢ Saldo: {user_info[3]:.2f} PRC
‚Ä¢ Equivalente: {user_info[3] * cup_rate:,.0f} CUP
‚Ä¢ Wallet: `{user_info[4]}`

üí± *Tasa actual:* 1 PRC = {cup_rate:,.0f} CUP

‚ö° *Selecciona una opci√≥n:*"""
        
        bot.edit_message_text(
            chat_id=call.message.chat.id,
            message_id=call.message.message_id,
            text=welcome_back_text,
            parse_mode='Markdown',
            reply_markup=main_menu(call.message.chat.id)
        )
    
    elif call.data == "confirm_clear":
        if is_admin(user_id):
            success = clear_database()
            if success:
                notification_text = f"""
üóëÔ∏è *BASE DE DATOS LIMPIADA* üóëÔ∏è

*Administrador:* {escape_markdown(call.from_user.first_name)}
*Fecha:* {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

‚úÖ *Todas las tablas han sido reiniciadas*
‚úÖ *Sistema listo para nuevos usuarios*"""
                
                send_group_notification(notification_text)
                
                bot.edit_message_text(
                    chat_id=call.message.chat.id,
                    message_id=call.message.message_id,
                    text="‚úÖ *Base de datos limpiada exitosamente*\n\nTodos los datos han sido eliminados y las tablas reiniciadas.",
                    parse_mode='Markdown'
                )
            else:
                bot.edit_message_text(
                    chat_id=call.message.chat.id,
                    message_id=call.message.message_id,
                    text="‚ùå *Error limpiando la base de datos*",
                    parse_mode='Markdown'
                )
    
    elif call.data == "cancel_clear":
        bot.edit_message_text(
            chat_id=call.message.chat.id,
            message_id=call.message.message_id,
            text="‚ùå *Limpieza cancelada*",
            parse_mode='Markdown'
        )

# =============================================================================
# FUNCIONES PARA DEP√ìSITOS CUP
# =============================================================================

def start_cup_deposit(call, method):
    cup_rate = get_cup_usd_rate()
    
    msg = bot.send_message(
        call.message.chat.id,
        f"üíµ *DEP√ìSITO POR {method.upper()}*\n\n"
        f"üí± *Tasa actual:* 1 PRC = {cup_rate:,.0f} CUP\n\n"
        f"üíµ Ingresa el monto en CUP que vas a depositar:",
        parse_mode='Markdown'
    )
    bot.register_next_step_handler(msg, process_cup_deposit_amount, method)

def process_cup_deposit_amount(message, method):
    try:
        amount_cup = float(message.text)
        user_id = message.from_user.id
        
        if amount_cup <= 0:
            bot.send_message(
                message.chat.id,
                "‚ùå *Monto inv√°lido*\nEl monto debe ser mayor a 0.",
                parse_mode='Markdown',
                reply_markup=main_menu(message.chat.id)
            )
            return
        
        # Obtener tasa actual
        cup_rate = get_cup_usd_rate()
        amount_prc = amount_cup / cup_rate
        
        # Guardar dep√≥sito pendiente
        deposit_id = f"DEP{uuid.uuid4().hex[:10].upper()}"
        pending_deposits[user_id] = {
            'deposit_id': deposit_id,
            'amount_cup': amount_cup,
            'amount_prc': amount_prc,
            'exchange_rate': cup_rate,
            'method': method
        }
        
        if method == "transfermovil":
            payment_text = f"""
üì± *INSTRUCCIONES PARA PAGO POR TRANSFERM√ìVIL*

üí≥ *Informaci√≥n para transferir:*
‚Ä¢ *Tel√©fono:* `5351234567`
‚Ä¢ *Nombre:* ProCoin Exchange
‚Ä¢ *Monto a transferir:* *{amount_cup:,.0f} CUP*

üìä *Conversi√≥n:*
‚Ä¢ CUP depositados: {amount_cup:,.0f} CUP
‚Ä¢ Tasa: 1 PRC = {cup_rate:,.0f} CUP
‚Ä¢ ProCoin a recibir: *{amount_prc:.2f} PRC*

üìã *Pasos a seguir:*
1. Abre tu app de Transferm√≥vil
2. Selecciona *\"Transferir\"*
3. Ingresa el tel√©fono: *5351234567*
4. Ingresa el monto: *{amount_cup:,.0f} CUP*
5. Confirma la transferencia
6. Toma una *captura de pantalla* del comprobante
7. Env√≠ala aqu√≠

‚ö†Ô∏è *Importante:* 
‚Ä¢ El monto debe ser *exactamente* {amount_cup:,.0f} CUP
‚Ä¢ Solo se aceptan transferencias desde CUENTAS PROPIAS
‚Ä¢ La verificaci√≥n puede tomar 5-15 minutos"""
        
        else:  # enzona
            payment_text = f"""
üîµ *INSTRUCCIONES PARA PAGO POR ENZONA*

üí≥ *Informaci√≥n para pagar:*
‚Ä¢ *Nombre:* ProCoin Exchange
‚Ä¢ *Monto a pagar:* *{amount_cup:,.0f} CUP*

üìä *Conversi√≥n:*
‚Ä¢ CUP depositados: {amount_cup:,.0f} CUP
‚Ä¢ Tasa: 1 PRC = {cup_rate:,.0f} CUP
‚Ä¢ ProCoin a recibir: *{amount_prc:.2f} PRC*

üìã *Pasos a seguir:*
1. Abre tu app de EnZona
2. Escanea el c√≥digo QR o busca *\"ProCoin Exchange\"*
3. Ingresa el monto: *{amount_cup:,.0f} CUP*
4. Realiza el pago
5. Toma una *captura de pantalla* del comprobante
6. Env√≠ala aqu√≠

‚ö†Ô∏è *Importante:* 
‚Ä¢ El monto debe ser *exactamente* {amount_cup:,.0f} CUP
‚Ä¢ Solo se aceptan pagos desde CUENTAS PROPIAS
‚Ä¢ La verificaci√≥n puede tomar 5-15 minutos"""
        
        # Registrar dep√≥sito pendiente
        log_deposit(deposit_id, user_id, amount_cup, amount_prc, cup_rate, method, "pending")
        
        bot.send_message(
            message.chat.id,
            payment_text,
            parse_mode='Markdown'
        )
        
        msg = bot.send_message(
            message.chat.id,
            "üì∏ *Ahora env√≠a la captura de pantalla del comprobante de pago:*",
            parse_mode='Markdown'
        )
        
    except ValueError:
        bot.send_message(
            message.chat.id,
            "‚ùå *Formato inv√°lido*\nIngresa un n√∫mero v√°lido.",
            parse_mode='Markdown',
            reply_markup=main_menu(message.chat.id)
        )

# =============================================================================
# FUNCIONES PARA RETIROS CUP
# =============================================================================

def start_cup_withdrawal(call):
    user_id = call.from_user.id
    user_info = get_user_info(user_id)
    cup_rate = get_cup_usd_rate()
    
    msg = bot.send_message(
        call.message.chat.id,
        f"üí∏ *RETIRAR CUP*\n\n"
        f"üíé *Saldo disponible:* {user_info[3]:.2f} PRC\n"
        f"üíµ *Equivalente:* {user_info[3] * cup_rate:,.0f} CUP\n\n"
        f"üí± *Tasa actual:* 1 PRC = {cup_rate:,.0f} CUP\n\n"
        f"üíé Ingresa la cantidad de ProCoin que deseas retirar (se convertir√°n a CUP):",
        parse_mode='Markdown'
    )
    bot.register_next_step_handler(msg, process_cup_withdraw_amount)

def process_cup_withdraw_amount(message):
    try:
        amount_prc = float(message.text)
        user_id = message.from_user.id
        user_info = get_user_info(user_id)
        
        if amount_prc <= 0:
            bot.send_message(
                message.chat.id,
                "‚ùå *Monto inv√°lido*\nEl monto debe ser mayor a 0.",
                parse_mode='Markdown',
                reply_markup=main_menu(message.chat.id)
            )
            return
        
        if amount_prc > user_info[3]:
            bot.send_message(
                message.chat.id,
                f"‚ùå *Saldo insuficiente*\n\n"
                f"Tu saldo: {user_info[3]:.2f} PRC\n"
                f"Monto a retirar: {amount_prc:.2f} PRC",
                parse_mode='Markdown',
                reply_markup=main_menu(message.chat.id)
            )
            return
        
        # Calcular fee del 2% (puedes ajustar)
        fee = amount_prc * 0.02
        net_amount_prc = amount_prc - fee
        
        # Obtener tasa actual
        cup_rate = get_cup_usd_rate()
        amount_cup = net_amount_prc * cup_rate
        
        # Guardar retiro pendiente
        withdrawal_id = f"WDL{uuid.uuid4().hex[:10].upper()}"
        pending_withdrawals[user_id] = {
            'withdrawal_id': withdrawal_id,
            'amount_prc': amount_prc,
            'amount_cup': amount_cup,
            'exchange_rate': cup_rate,
            'fee': fee,
            'net_amount': net_amount_prc
        }
        
        bot.send_message(
            message.chat.id,
            f"üí≥ *INGRESA TU N√öMERO DE TARJETA*\n\n"
            f"üìã *Resumen del retiro:*\n"
            f"‚Ä¢ ProCoin a retirar: {amount_prc:.2f} PRC\n"
            f"‚Ä¢ Fee (2%): {fee:.2f} PRC\n"
            f"‚Ä¢ Neto a convertir: {net_amount_prc:.2f} PRC\n"
            f"‚Ä¢ Tasa: 1 PRC = {cup_rate:,.0f} CUP\n"
            f"‚Ä¢ Recibir√°s: {amount_cup:,.0f} CUP\n\n"
            f"üî¢ *Ingresa el n√∫mero de tu tarjeta:*",
            parse_mode='Markdown'
        )
        
        bot.register_next_step_handler(message, process_cup_withdraw_card)
        
    except ValueError:
        bot.send_message(
            message.chat.id,
            "‚ùå *Formato inv√°lido*\nIngresa un n√∫mero v√°lido.",
            parse_mode='Markdown',
            reply_markup=main_menu(message.chat.id)
        )

def process_cup_withdraw_card(message):
    user_id = message.from_user.id
    user_info = get_user_info(user_id)
    card_number = message.text.strip()
    
    if user_id not in pending_withdrawals:
        bot.send_message(
            message.chat.id,
            "‚ùå *No hay retiro pendiente*",
            parse_mode='Markdown',
            reply_markup=main_menu(message.chat.id)
        )
        return
    
    withdrawal_data = pending_withdrawals[user_id]
    withdrawal_id = withdrawal_data['withdrawal_id']
    
    if len(card_number) < 10:
        bot.send_message(
            message.chat.id,
            "‚ùå *N√∫mero de tarjeta inv√°lido*\n\nIngresa un n√∫mero de tarjeta v√°lido.",
            parse_mode='Markdown',
            reply_markup=main_menu(message.chat.id)
        )
        return
    
    # Registrar retiro en la base de datos
    log_withdrawal(withdrawal_id, user_id, 
                  withdrawal_data['amount_prc'], withdrawal_data['amount_cup'],
                  withdrawal_data['exchange_rate'], withdrawal_data['fee'],
                  withdrawal_data['net_amount'], card_number, "pending")
    
    # Actualizar balance (congelar fondos)
    update_balance(user_id, -withdrawal_data['amount_prc'])
    
    # Notificar al grupo
    group_notification = f"""
üì§ *NUEVA SOLICITUD DE RETIRO CUP* üì§

*Usuario:* {escape_markdown(user_info[2])}
*Wallet:* `{user_info[4]}`
*ProCoin a retirar:* {withdrawal_data['amount_prc']:.2f} PRC
*CUP a recibir:* {withdrawal_data['amount_cup']:,.0f} CUP
*Tasa:* 1 PRC = {withdrawal_data['exchange_rate']:,.0f} CUP
*Fee (2%):* {withdrawal_data['fee']:.2f} PRC
*Tarjeta:* `{card_number}`
*Retiro ID:* `{withdrawal_id}`

‚è≥ *Esperando procesamiento...*

üíæ *Para aprobar usa:*
`/recargar {user_info[4]} {withdrawal_data['amount_prc']}`"""
    
    send_group_notification(group_notification)
    
    # Confirmar al usuario
    bot.send_message(
        message.chat.id,
        f"‚úÖ *Solicitud de retiro enviada*\n\n"
        f"üìã *Detalles de tu retiro:*\n"
        f"‚Ä¢ ProCoin: {withdrawal_data['amount_prc']:.2f} PRC\n"
        f"‚Ä¢ Fee (2%): {withdrawal_data['fee']:.2f} PRC\n"
        f"‚Ä¢ Neto convertido: {withdrawal_data['net_amount']:.2f} PRC\n"
        f"‚Ä¢ CUP a recibir: {withdrawal_data['amount_cup']:,.0f} CUP\n"
        f"‚Ä¢ Tarjeta: {card_number}\n"
        f"‚Ä¢ Retiro ID: {withdrawal_id}\n\n"
        f"‚è∞ *Estado:* Pendiente de aprobaci√≥n\n"
        f"üìû *Tiempo estimado:* 5-15 minutos\n\n"
        f"Te notificaremos cuando sea procesado.",
        parse_mode='Markdown',
        reply_markup=main_menu(message.chat.id)
    )
    
    # Limpiar retiro pendiente
    del pending_withdrawals[user_id]

# =============================================================================
# FUNCIONES DE INFORMACI√ìN
# =============================================================================

def show_complete_balance(call):
    user_id = call.from_user.id
    user_info = get_user_info(user_id)
    
    # Obtener tasas actuales
    cup_rate = get_cup_usd_rate()
    
    balance_text = f"""
üí∞ *BALANCE COMPLETO*

üíé *Balance ProCoin:*
‚Ä¢ Saldo disponible: {user_info[3]:.2f} PRC
‚Ä¢ Equivalente en CUP: {user_info[3] * cup_rate:,.0f} CUP

üè¶ *Valor total:* {user_info[3]:.2f} PRC
üíµ *Equivalente total CUP:* {user_info[3] * cup_rate:,.0f} CUP"""
    
    bot.edit_message_text(
        chat_id=call.message.chat.id,
        message_id=call.message.message_id,
        text=balance_text,
        parse_mode='Markdown',
        reply_markup=main_menu(call.message.chat.id)
    )

def show_current_rates(call_or_message):
    """Muestra TODAS las tasas actuales de cambio desde la API de ElToque"""
    try:
        print("üîç Iniciando obtenci√≥n de tasas...")
        send_group_notification("üîç *Solicitud Tasas:* Usuario solicitando tasas actuales")
        
        # Obtener todas las tasas desde el cach√©
        all_rates = get_eltoque_rates_cached()
        print(f"üìä Tasas obtenidas: {all_rates}")
        
        if not all_rates:
            # Si no hay tasas, usar valores por defecto
            all_rates = {
                'USD': 490,
                'USDT_TRC20': 517, 
                'MLC': 200,
                'ECU': 540,
                'BTC': 490,
                'TRX': 180
            }
            print("‚ö†Ô∏è No se obtuvieron tasas, usando valores por defecto")
            send_group_notification("‚ö†Ô∏è *Sistema Tasas:* Usando tasas por defecto")

        # Determinar la tasa principal para ProCoin (USD por defecto)
        main_rate = all_rates.get('USD') 
        if main_rate is None:
            main_rate = all_rates.get('USDT_TRC20', 490.0)
        print(f"üí∞ Tasa principal (USD): {main_rate}")

        # Construir el mensaje principal
        rates_text = f"""
üìà *TODAS LAS TASAS DE CAMBIO*

üíé *Tasa Principal ProCoin:*
‚Ä¢ 1 PRC = {main_rate:,} CUP

üí± *Tasas Disponibles:*
"""
        
        # Ordenar las tasas para mejor presentaci√≥n
        sorted_rates = sorted(all_rates.items(), key=lambda x: x[0])
        
        for currency, rate in sorted_rates:
            rates_text += f"‚Ä¢ {currency}: {rate:,} CUP\n"

        # Conversiones comunes de ProCoin
        rates_text += f"""
üìä *Conversiones ProCoin:*
‚Ä¢ 10 PRC = {10 * main_rate:,} CUP
‚Ä¢ 50 PRC = {50 * main_rate:,} CUP  
‚Ä¢ 100 PRC = {100 * main_rate:,} CUP

üí° *Informaci√≥n Importante:*
"""
        
        if 'MLC' in all_rates:
            mlc_rate = all_rates['MLC']
            rates_text += f"‚Ä¢ 1 MLC = {mlc_rate:,} CUP\n"
            
        if 'USDT_TRC20' in all_rates:
            usdt_rate = all_rates['USDT_TRC20']
            rates_text += f"‚Ä¢ 1 USDT = {usdt_rate:,} CUP\n"
            
        if 'BTC' in all_rates:
            btc_rate = all_rates['BTC']
            rates_text += f"‚Ä¢ 1 BTC = {btc_rate:,} CUP\n"
            
        if 'TRX' in all_rates:
            trx_rate = all_rates['TRX']
            rates_text += f"‚Ä¢ 1 TRX = {trx_rate:,} CUP\n"

        rates_text += f"\nüîÑ Actualizado: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"

        print("‚úÖ Mensaje de tasas construido, enviando...")
        send_group_notification("‚úÖ *Sistema Tasas:* Tasas enviadas al usuario correctamente")
        
        # Env√≠o del mensaje con Markdown normal
        if hasattr(call_or_message, 'message'):
            # Es un CallbackQuery (desde bot√≥n inline)
            chat_id = call_or_message.message.chat.id
            message_id = call_or_message.message.message_id
            
            bot.edit_message_text(
                chat_id=chat_id,
                message_id=message_id,
                text=rates_text,
                parse_mode='Markdown',
                reply_markup=main_menu(chat_id)
            )
        else:
            # Es un Message (desde comando /tasas)
            chat_id = call_or_message.chat.id
            bot.send_message(
                chat_id,
                rates_text,
                parse_mode='Markdown',
                reply_markup=main_menu(chat_id)
            )
            
    except Exception as e:
        print(f"‚ùå Error en show_current_rates: {e}")
        traceback.print_exc()
        send_group_notification(f"‚ùå *Error Tasas:* Error en show_current_rates: {e}")
        
        error_text = "‚ùå *Error obteniendo tasas*\n\nPor favor, intenta nuevamente en unos momentos."
        
        if hasattr(call_or_message, 'message'):
            chat_id = call_or_message.message.chat.id
            message_id = call_or_message.message.message_id
            bot.edit_message_text(
                chat_id=chat_id,
                message_id=message_id,
                text=error_text,
                parse_mode='Markdown',
                reply_markup=main_menu(chat_id)
            )
        else:
            chat_id = call_or_message.chat.id
            bot.send_message(
                chat_id,
                error_text,
                parse_mode='Markdown',
                reply_markup=main_menu(chat_id)
            )

# =============================================================================
# MANEJADOR DE CAPTURAS DE PANTALLA
# =============================================================================

@bot.message_handler(content_types=['photo'])
def handle_screenshot(message):
    user_id = message.from_user.id
    user_info = get_user_info(user_id)
    
    if user_id in pending_deposits:
        # Es un dep√≥sito CUP
        deposit_data = pending_deposits[user_id]
        deposit_id = deposit_data['deposit_id']
        amount_cup = deposit_data['amount_cup']
        amount_prc = deposit_data['amount_prc']
        method = deposit_data['method']
        
        photo_id = message.photo[-1].file_id
        
        conn = sqlite3.connect('cubawallet.db')
        cursor = conn.cursor()
        cursor.execute('UPDATE deposits SET screenshot_id = ? WHERE deposit_id = ?', (photo_id, deposit_id))
        conn.commit()
        conn.close()
        
        method_display = "Transferm√≥vil" if method == "transfermovil" else "EnZona"
        
        group_notification = f"""
üì• *NUEVO DEP√ìSITO CUP PENDIENTE* üì•

*Usuario:* {escape_markdown(user_info[2])}
*Wallet:* `{user_info[4]}`
*M√©todo:* {method_display}
*CUP depositados:* {amount_cup:,.0f} CUP
*ProCoin a recibir:* {amount_prc:.2f} PRC
*Tasa:* 1 PRC = {deposit_data['exchange_rate']:,.0f} CUP
*Dep√≥sito ID:* `{deposit_id}`

‚è≥ *Esperando verificaci√≥n...*

üíæ *Para aprobar usa:*
`/recargar {user_info[4]} {amount_prc}`"""
        
        send_group_notification(group_notification, photo_id=photo_id)
        
        bot.reply_to(message,
                    f"‚úÖ *Captura recibida*\n\n"
                    f"Hemos recibido tu comprobante por {amount_cup:,.0f} CUP\n\n"
                    f"üìä *Conversi√≥n:*\n"
                    f"‚Ä¢ CUP: {amount_cup:,.0f} CUP\n"
                    f"‚Ä¢ Tasa: 1 PRC = {deposit_data['exchange_rate']:,.0f} CUP\n"
                    f"‚Ä¢ ProCoin a recibir: {amount_prc:.2f} PRC\n\n"
                    f"üìã *Estado:* En revisi√≥n\n"
                    f"üÜî *Dep√≥sito:* {deposit_id}\n"
                    f"‚è∞ *Tiempo estimado:* 5-15 minutos\n\n"
                    f"Te notificaremos cuando sea verificado.",
                    parse_mode='Markdown',
                    reply_markup=main_menu(message.chat.id))
        
        del pending_deposits[user_id]

# =============================================================================
# FUNCIONES DE TRANSFERENCIA ENTRE USUARIOS
# =============================================================================

def process_recipient(message):
    recipient_address = message.text.strip()
    user_id = message.from_user.id
    user_info = get_user_info(user_id)
    
    # Verificar si la direcci√≥n existe
    recipient_info = get_user_by_wallet(recipient_address)
    
    if not recipient_info:
        bot.send_message(
            message.chat.id,
            "‚ùå *Direcci√≥n no encontrada*\n\nVerifica la direcci√≥n e intenta nuevamente.",
            parse_mode='Markdown',
            reply_markup=main_menu(message.chat.id)
        )
        return
    
    if recipient_info[0] == user_id:
        bot.send_message(
            message.chat.id,
            "‚ùå *No puedes enviarte ProCoin a ti mismo*",
            parse_mode='Markdown',
            reply_markup=main_menu(message.chat.id)
        )
        return
    
    bot.send_message(
        message.chat.id,
        f"‚úÖ *Destinatario encontrado:* {escape_markdown(recipient_info[2])}\n\nüíé Ingresa la cantidad de ProCoin a enviar:",
        parse_mode='Markdown'
    )
    
    bot.register_next_step_handler(message, process_amount, recipient_info)

def process_amount(message, recipient_info):
    try:
        amount = float(message.text)
        user_id = message.from_user.id
        user_info = get_user_info(user_id)
        
        if amount <= 0:
            bot.send_message(
                message.chat.id,
                "‚ùå *Monto inv√°lido*\nEl monto debe ser mayor a 0.",
                parse_mode='Markdown',
                reply_markup=main_menu(message.chat.id)
            )
            return
        
        if amount > user_info[3]:
            bot.send_message(
                message.chat.id,
                f"‚ùå *Saldo insuficiente*\n\nTu saldo: {user_info[3]:.2f} PRC\nMonto a enviar: {amount:.2f} PRC",
                parse_mode='Markdown',
                reply_markup=main_menu(message.chat.id)
            )
            return
        
        confirm_markup = types.InlineKeyboardMarkup()
        confirm_btn = types.InlineKeyboardButton("‚úÖ Confirmar Env√≠o", callback_data=f"confirm_send_{amount}_{recipient_info[0]}")
        cancel_btn = types.InlineKeyboardButton("‚ùå Cancelar", callback_data="cancel_send")
        confirm_markup.add(confirm_btn, cancel_btn)
        
        bot.send_message(
            message.chat.id,
            f"üîç *CONFIRMAR TRANSACCI√ìN*\n\n"
            f"üë§ *Destinatario:* {escape_markdown(recipient_info[2])}\n"
            f"üÜî *Wallet:* {recipient_info[4]}\n"
            f"üíé *Monto:* {amount:.2f} PRC\n\n"
            f"¬øConfirmas esta transacci√≥n?",
            parse_mode='Markdown',
            reply_markup=confirm_markup
        )
        
    except ValueError:
        bot.send_message(
            message.chat.id,
            "‚ùå *Formato inv√°lido*\nIngresa un n√∫mero v√°lido.",
            parse_mode='Markdown',
            reply_markup=main_menu(message.chat.id)
        )

@bot.callback_query_handler(func=lambda call: call.data.startswith('confirm_send_'))
def confirm_send(call):
    try:
        data_parts = call.data.split('_')
        amount = float(data_parts[2])
        recipient_id = int(data_parts[3])
        
        user_id = call.from_user.id
        user_info = get_user_info(user_id)
        recipient_info = get_user_info(recipient_id)
        
        if amount > user_info[3]:
            bot.answer_callback_query(call.id, "‚ùå Saldo insuficiente")
            return
        
        transaction_id = f"TXN{uuid.uuid4().hex[:10].upper()}"
        
        update_balance(user_id, -amount)
        update_balance(recipient_id, amount)
        
        log_transaction(transaction_id, user_id, recipient_id, amount, "transfer", "completed")
        
        success_text = f"""
‚úÖ *TRANSACCI√ìN EXITOSA*

üíé ProCoin enviados: {amount:.2f} PRC
üë§ Destinatario: {escape_markdown(recipient_info[2])}
üÜî Transacci√≥n: {transaction_id}
üìÖ Fecha: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

üí∞ Nuevo saldo: *{user_info[3] - amount:.2f} PRC*"""
        
        bot.edit_message_text(
            chat_id=call.message.chat.id,
            message_id=call.message.message_id,
            text=success_text,
            parse_mode='Markdown',
            reply_markup=main_menu(call.message.chat.id)
        )
        
        try:
            recipient_notification = f"""
üí∞ *HAS RECIBIDO PROCOIN*

üíé ProCoin recibidos: {amount:.2f} PRC
üë§ Remitente: {escape_markdown(user_info[2])}
üÜî Transacci√≥n: {transaction_id}

üí≥ Nuevo saldo: *{recipient_info[3] + amount:.2f} PRC*"""
            
            bot.send_message(
                chat_id=recipient_id,
                text=recipient_notification,
                parse_mode='Markdown'
            )
        except:
            pass
        
    except Exception as e:
        print(f"Error en transacci√≥n: {e}")
        bot.answer_callback_query(call.id, "‚ùå Error en la transacci√≥n")

@bot.callback_query_handler(func=lambda call: call.data == 'cancel_send')
def cancel_send(call):
    bot.edit_message_text(
        chat_id=call.message.chat.id,
        message_id=call.message.message_id,
        text="‚ùå *Transacci√≥n cancelada*",
        parse_mode='Markdown',
        reply_markup=main_menu(call.message.chat.id)
    )

# =============================================================================
# COMANDO PARA VER SALDO
# =============================================================================

@bot.message_handler(commands=['saldo'])
def show_balance_command(message):
    user_id = message.from_user.id
    user_info = get_user_info(user_id)
    
    if user_info:
        cup_rate = get_cup_usd_rate()
        bot.send_message(
            message.chat.id,
            f"üí∞ *Tu saldo actual:* {user_info[3]:.2f} PRC\nüíµ *Equivalente:* {user_info[3] * cup_rate:,.0f} CUP",
            parse_mode='Markdown',
            reply_markup=main_menu(message.chat.id)
        )

# =============================================================================
# FUNCIONES DE DEBUG Y TESTING
# =============================================================================

def test_cache_system():
    """Prueba el sistema de cach√©"""
    print("üß™ Probando sistema de cach√©...")
    send_group_notification("üß™ *Debug:* Probando sistema de cach√©...")
    
    # Primera llamada - deber√≠a hacer petici√≥n
    start_time = time.time()
    rates1 = get_eltoque_rates_cached()
    time1 = time.time() - start_time
    
    # Segunda llamada inmediata - deber√≠a usar cach√©
    start_time = time.time()
    rates2 = get_eltoque_rates_cached()
    time2 = time.time() - start_time
    
    print(f"‚è±Ô∏è Tiempo primera llamada: {time1:.3f}s")
    print(f"‚è±Ô∏è Tiempo segunda llamada: {time2:.3f}s")
    print(f"‚úÖ Cach√© funcionando: {time2 < time1 and time2 < 0.01}")
    
    debug_msg = f"""
üß™ *RESULTADO TEST CACH√â:*
‚Ä¢ Tiempo primera llamada: {time1:.3f}s
‚Ä¢ Tiempo segunda llamada: {time2:.3f}s
‚Ä¢ Cach√© funcionando: {'‚úÖ S√≠' if (time2 < time1 and time2 < 0.01) else '‚ùå No'}
‚Ä¢ Tasas obtenidas: {len(rates1) if rates1 else 0}"""
    
    send_group_notification(debug_msg)
    
    return rates1 is not None

def test_eltoque_api():
    """Funci√≥n para probar la conexi√≥n con la API de ElToque"""
    print("üß™ Probando conexi√≥n con API ElToque...")
    send_group_notification("üß™ *Debug:* Probando conexi√≥n con API ElToque...")
    
    try:
        # Formatear fechas para hoy
        today = datetime.now().strftime("%Y-%m-%d")
        date_from = f"{today} 00:00:01"
        date_to = f"{today} 23:59:01"
        
        params = {
            'date_from': date_from,
            'date_to': date_to
        }
        
        headers = {
            'accept': '*/*',
            'Authorization': f'Bearer {ELTOQUE_API_TOKEN}',
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        }
        
        print(f"üîó URL: {ELTOQUE_API_URL}")
        print(f"üìÖ Par√°metros: {params}")
        print(f"üîë Token (primeros 20 chars): {ELTOQUE_API_TOKEN[:20]}...")
        
        response = requests.get(ELTOQUE_API_URL, params=params, headers=headers, timeout=15)
        
        print(f"üì° Status Code: {response.status_code}")
        
        if response.status_code == 200:
            data = response.json()
            print("‚úÖ API funciona correctamente")
            print(f"üìä Estructura de datos: {list(data.keys()) if isinstance(data, dict) else 'No es dict'}")
            
            if 'tasas' in data:
                print(f"üí∞ Tasas disponibles: {data['tasas']}")
                tasas_resumen = ", ".join([f"{k}: {v}" for k, v in data['tasas'].items()])
                debug_msg = f"""
‚úÖ *RESULTADO TEST API:*
‚Ä¢ Status: 200 OK
‚Ä¢ Estructura: {list(data.keys())}
‚Ä¢ Tasas: {tasas_resumen}"""
            else:
                print("‚ùå No se encontr√≥ el campo 'tasas' en la respuesta")
                debug_msg = f"""
‚ùå *RESULTADO TEST API:*
‚Ä¢ Status: 200 OK
‚Ä¢ Error: No se encontr√≥ campo 'tasas'
‚Ä¢ Estructura: {list(data.keys()) if isinstance(data, dict) else type(data)}"""
                
            send_group_notification(debug_msg)
            return True
        else:
            print(f"‚ùå Error API: {response.status_code}")
            print(f"üìÑ Respuesta: {response.text}")
            debug_msg = f"""
‚ùå *RESULTADO TEST API:*
‚Ä¢ Status: {response.status_code}
‚Ä¢ Error: {response.text}"""
            send_group_notification(debug_msg)
            return False
            
    except Exception as e:
        print(f"‚ùå Error en test: {e}")
        traceback.print_exc()
        debug_msg = f"""
‚ùå *ERROR TEST API:*
‚Ä¢ Excepci√≥n: {e}"""
        send_group_notification(debug_msg)
        return False

# =============================================================================
# INICIALIZACI√ìN Y EJECUCI√ìN
# =============================================================================

def run_bot():
    """Ejecuta el bot de Telegram en un hilo separado"""
    print("üß† Inicializando base de datos...")
    send_group_notification("üß† *Sistema:* Inicializando base de datos...")
    init_db()
    
    # Probar la API de ElToque y el cach√© al inicio
    print("üß™ Probando API ElToque y sistema de cach√©...")
    send_group_notification("üß™ *Sistema:* Probando API ElToque y sistema de cach√©...")
    
    api_works = test_eltoque_api()
    cache_works = test_cache_system()
    
    if api_works and cache_works:
        print("‚úÖ API ElToque y cach√© funcionando correctamente")
        send_group_notification("‚úÖ *Sistema:* API ElToque y cach√© funcionando correctamente")
    else:
        print("‚ùå Problemas con API o cach√©, usando tasas por defecto")
        send_group_notification("‚ùå *Sistema:* Problemas con API o cach√©, usando tasas por defecto")
    
    print("ü§ñ Iniciando bot ProCoin...")
    print(f"üëë Administrador: {ADMIN_ID}")
    print(f"üì¢ Notificaciones al grupo: {GROUP_CHAT_ID}")
    
    # Probar notificaciones al inicio
    test_msg = "üîî *Bot ProCoin iniciado* - Sistema con API ElToque y cach√© activo"
    send_group_notification(test_msg)
    
    try:
        print("üîÑ Iniciando polling del bot...")
        send_group_notification("üîÑ *Sistema:* Iniciando polling del bot...")
        bot.polling(none_stop=True)
    except Exception as e:
        error_msg = f"‚ùå Error en el bot: {e}"
        print(error_msg)
        send_group_notification(f"‚ùå *Error Sistema:* {error_msg}")
        time.sleep(10)
        run_bot()

if __name__ == "__main__":
    # Iniciar el bot en un hilo separado
    bot_thread = threading.Thread(target=run_bot)
    bot_thread.daemon = True
    bot_thread.start()
    
    # Mantener el script principal ejecut√°ndose
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        print("üëã Deteniendo bot...")
        send_group_notification("üëã *Sistema:* Bot detenido por el usuario")
